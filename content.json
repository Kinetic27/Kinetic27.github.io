{"pages":[{"title":"About Kinetic","text":"Kinetic27&nbsp; Hello world!&nbsp; I am noob student developer. 👨‍💻 I like to develop many interesting things. 🎁 Seeking software that can be useful✨ and convenient🎉 for someone to use, and many things to develop in a fun way. Online Judge 💻 BOJ: Kinetic27 solvedac: Kinetic27 Contacts 📫 Github Repo Issue Twitter DM Email: aheui@kakao.com Github","link":"/about/index.html"},{"title":"My webpages!","text":"만들어본 웹페이지들시계 open ref: https://youtu.be/Ki0XXrlKlHY 계산기 open ref: https://youtu.be/j59qQ7YWLxw 퀴즈 open ref: https://youtu.be/riDzcEQbX6k 할 일 목록 open ref: https://velopert.com/3480 영화 앱 open ref: https://nomadcoders.co/react-fundamentals/lobby","link":"/pages/index.html"},{"title":"Donation List!","text":"후원자 페이지 Github","link":"/donations/index.html"}],"posts":[{"title":"파이썬 셀레니움으로 네이버 기사 댓글 크롤링하기","text":"파이썬 셀레니움으로 네이버 기사 댓글 크롤링을 해보자 파이썬 셀레니움으로 네이버 기사 댓글 크롤링하기 코드123456789101112131415import osfrom selenium import webdriverdriver = webdriver.Chrome(os.getcwd() + '/chromedriver')driver.implicitly_wait(50)driver.get('https://news.naver.com/main/read.nhn?m_view=1&amp;includeAllCount=true&amp;mode=LSD&amp;mid=sec&amp;sid1=102&amp;oid=003&amp;aid=0009172141')cBox = driver.find_elements_by_css_selector('div[class=u_cbox_comment_box]')cList = []for i in range(cBox.__len__()): cList.append(cBox[i].find_element_by_css_selector('span[class=u_cbox_contents]').text)print(cList) 보다시피 기사의 댓글들을 담아둔 div를 cssSelector를 통해서 div[class=u_cbox_comment_box] 를 가져오고반복문을 돌며 각각의 텍스트를 가져와 cList에 담는 간단한 코드입니다. 현 시점으로 작동하지만 네이버 사이트 구조가 바뀌면 작동하지 않을 수도 있습니다 :)","link":"/2019/05/25/python-naver-crawling/"},{"title":"코틀린으로 짠 마름모 별찍기","text":"Kotlin의 range를 이용하여 ♦마름모♦를 출력해보자 Kotlin으로 Int범위의 양수 n을 입력해주면 한 변의 길이가 n인 마름모를 출력! 코드123456789import java.util.Scannerfun main(args: Array&lt;String&gt;) { val n = Scanner(System.`in`).nextInt() - 1 ((0 until n) + (n downTo 0)).forEach { println(\"${\" \".repeat(n - it)}*${\"*\".repeat(2 * it)}\") }} 입력1ex) 9 출력1234567891011121314151617 * *** ***** ******* ********* *********** ************* ******************************** *************** ************* *********** ********* ******* ***** *** * kotlin에서 range끼리 더해서 합칠 수 있다는걸 우연히 알았습니다 잘 작동합니다 :)","link":"/2019/02/13/kotlin-star/"},{"title":"[Level 1] 프로그래머스 완전탐색 모의고사 kotlin 풀이","text":"완전탐색! 프로그래머스 “모의고사” 문제를 풀어보자 문제 소개이번 문제는 프로그래머스 사이트에 들어가서 Kotlin탭에 처음으로 나와있던 문제라서 한번 풀어보게되었어요. 수포자 3명이 문제를 찍어서 답을 내면 누가 제일 많이 맞췄나를 알려주는 문제네요. 1번 수포자는 1, 2, 3, 4, 5 순서로 번갈아서 찍고 2번 수포자는 홀수번에는 2 짝수번에는 1, 3, 4, 5로 번갈아서 찍습니다. 3번 수포자는 3, 1, 2, 4, 5를 각각 2번씩 찍습니다. 문제 풀이수포자 배열 생성보자마자 저는 우선 3가지를 각각 배열로 표현해봤어요. 1번 수포자는 1Array(answers.size) { it % 5 + 1 } 로 간단하게 나타낼 수 있습니다. 5로 나눈 나머지에 각각 1을 더해 정답의 크기와 맞춰주는 쉬운 코드입니다. 2번 수포자는 1Array(answers.size) { if ((it + 1) % 2 != 0) 2 else arrayOf(1, 3, 4, 5)[it / 2 % 4] } 이렇게 짜봤는데요. 홀수를 판별해서 2를 넣고 아닐경우 [1, 3, 4, 5]에서 꺼내가도록 했습니다. 3번 수포자는 1Array(answers.size) { arrayOf(3, 1, 2, 4, 5)[(Math.round((it / 2).toDouble()) % 5).toInt()] } Math.round((it / 2)를 하면 11 22 33 44 55 66 이런식으로 나올테니 5로나눈 나머지를 이용해서 [3, 1, 2, 4, 5]에서 가져가게 했습니다. 정답 배열과 일치하는 수 알아내기12fun Array&lt;Int&gt;.sameSize(answer: IntArray) =this.filterIndexed { index, i -&gt; answer[index] == i }.size filter를 이용하는데 index가 달린 필터를 이용해서 해당 원소가 정답 배열의 원소와 일치하면 남겨두고 우리가 필요한건 개수만 알면 되니 .size 를 이용해서 수만 반환해주었습니다. 이걸로 아까 짠 수포자 배열에 각각 적용해서 배열을 선언하였습니다. 12345val size1 = Array(answers.size) { it % 5 + 1 }.sameSize(answers)val size2 = Array(answers.size) { if ((it + 1) % 2 != 0) 2 else arrayOf(1, 3, 4, 5)[it / 2 % 4] }.sameSize(answers)val size3 = Array(answers.size) { arrayOf(3, 1, 2, 4, 5)[(Math.round((it / 2).toDouble()) % 5).toInt()] }.sameSize(answers) 정답 반환시도 1번, 이차원 배열 이용12345678910111213141516171819202122val answer: Array&lt;Array&lt;Int&gt;&gt; = arrayOf(arrayOf(1, size1), arrayOf(2, size2), arrayOf(3, size3)).apply { sortBy { it[1] }}answer.reverse()return when { answer[0][1] == answer[1][1] &amp;&amp; answer[0][1] == answer[2][1] -&gt; intArrayOf( answer[0][0], answer[1][0], answer[2][0] ).apply{ sort() } answer[0][1] == answer[1][1] &amp;&amp; answer[0][1] != answer[2][1] -&gt; intArrayOf( answer[0][0], answer[1][0] ).apply{ sort() } else -&gt; intArrayOf( answer[0][0] )} 처음에 시도해서 정답을 받은 코드인데요.보다시피 answer이라는 배열에 [수포자번호, 맞춘 개수]를 담고 맞춘 개수를 기준으로 정렬하였습니다. 하지만 오름차순으로 정렬되니 문제를 가장 적게 맞춘 수포자 순으로 정렬되니 1answer.reverse() 를 통해서 배열을 뒤집어 줍니다. 그러면 [[2, 15], [1, 5], [3, 8]] 이런식으로 정렬이 될겁니다. 저는 그 다음 조건문을 이용해서 답을 제출하려했습니다. 동점자가 나올 수 있으니 케이스를 점수에 따라 3개로 분기쳐서 셋 모두 점수가 같은 경우 -&gt; [배열의 1번, 배열의 2번, 배열의 3번] 앞의 둘만 같은 경우 -&gt; [배열의 1번, 배열의 2번] 셋다 다른 경우 -&gt; [배열의 1번] 이런식으로 처리하는 코드를 작성했습니다. 근데 예를 들어 2, 3번이 같은경우 answer에선 reverse()를 했기 때문에 3, 2가 들어있기 떄문에 .apply{sort()}를 통해서 재정렬 해줬습니다. 다시 reverse()해도 될법한데 생각을 못했네요. ;( 다 풀고나서 다른분들 코드를 보다가 map이 생각났습니다. 그래서 재시도를 해봤죠. 시도 2번, map이용하기사실 이번 풀이에 map만큼 적합한건 없는것 같아요. 123mapOf(Pair(1, size1), Pair(2, size2), Pair(3, size3)).run { filter { map -&gt; map.value == this.maxBy { it.value }?.value } }.keys.sorted().toIntArray() 제가 다시 짠 코드는 이러합니다. 우선 아까와 마찬가지로 미리 각 수포자들의 맞춘 개수를 각각 size1, size2, size3로 넣어뒀습니다. 그다음 filter를 통해서 this.maxBy { it.value }?.value } 즉 map에서 제일 큰 값(최고득점자)와 점수가 같은 사람만 남겼습니다. 그러면 최고득점자들만 남게됩니다. 이때 key들(수포자의 이름)을 .keys.sorted().toIntArray()를 통해서 오름차순 정렬한 후 List&lt;Int&gt;를 IntArray로 바꿔줍니다. 이 풀이가 더욱 깔끔한 풀이같네요! 정답 코드처음에 제출한 코드(이차원배열)123456789101112131415161718192021222324252627282930313233343536373839404142class Solution { fun solution(answers: IntArray): IntArray { val size1 = Array(answers.size) { i -&gt; i % 5 + 1 }.sameSize(answers) val size2 = Array(answers.size) { i -&gt; if ((i + 1) % 2 != 0) 2 else arrayOf(1, 3, 4, 5)[i / 2 % 4] }.sameSize(answers) val size3 = Array(answers.size) { i -&gt; when (Math.round((i / 2).toDouble()) % 5) { 0L -&gt; 3 1L -&gt; 1 2L -&gt; 2 3L -&gt; 4 else -&gt; 5 } }.sameSize(answers) val answer: Array&lt;Array&lt;Int&gt;&gt; = arrayOf(arrayOf(1, size1), arrayOf(2, size2), arrayOf(3, size3)).apply { sortBy { it[1] } } answer.reverse() return when { answer[0][1] == answer[1][1] &amp;&amp; answer[0][1] == answer[2][1] -&gt; intArrayOf( answer[0][0], answer[1][0], answer[2][0] ).apply{ sort() } answer[0][1] == answer[1][1] &amp;&amp; answer[0][1] != answer[2][1] -&gt; intArrayOf( answer[0][0], answer[1][0] ).apply{ sort() } else -&gt; intArrayOf( answer[0][0] ) } } fun Array&lt;Int&gt;.sameSize(answer: IntArray) = this.filterIndexed { index, i -&gt; answer[index] == i }.size} 다시 제출한 코드(map이용)12345678910111213141516class Solution { fun solution(answers: IntArray): IntArray { val size1 = Array(answers.size) { it % 5 + 1 }.sameSize(answers) val size2 = Array(answers.size) { if ((it + 1) % 2 != 0) 2 else arrayOf(1, 3, 4, 5)[it / 2 % 4] }.sameSize(answers) val size3 = Array(answers.size) { arrayOf(3, 1, 2, 4, 5)[(Math.round((it / 2).toDouble()) % 5).toInt()] }.sameSize(answers) return mapOf(Pair(1, size1), Pair(2, size2), Pair(3, size3)).run { filter { map -&gt; map.value == this.maxBy { it.value }?.value } }.keys.sorted().toIntArray() } fun Array&lt;Int&gt;.sameSize(answer: IntArray) = // 일치하는 개수 반환 this.filterIndexed { index, i -&gt; answer[index] == i }.size} 나름 간결하게 잘 풀어낸거같네요! 출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges","link":"/2020/02/29/programmers-mock-exam/"},{"title":"[Level 1] 프로그래머스 K번째 수 kotlin 풀이","text":"정렬! 프로그래머스 “K번째 수” 문제를 풀어보자 문제 소개이번에 풀어볼 문제는 프로그래머스 코테 Level-1 K번째 수 라는 문제입니다! 이번 문제는 그냥 자르기 - 정렬 - 찾기 로 끝나는 간단한 문제로 보입니다. 문제 풀이풀이도 간단합니다! 입력받은 array를 커멘드[0]에서 커멘드[1] 까지 slice 하면 되는데우리는 zero-based-numbering을 사용하고있으니 1씩 빼서 범위를 잡습니다. zero-based-numbering은 시작 index를 0으로 세는 indexing 방법을 이야기합니다. 그다음 kotlin 내장 정렬기능을 이용해서 정렬 후 정렬된 Int 배열에서 커멘드[2]에서 마찬가지로 1을 뺀 수를 index로 가지는 수를 가져와서 새로운 배열에 넣어 제출하면 되겠네요! 정답 코드1번 코드그래서 처음에 짠 코드는 이러합니다. 1234567891011class Solution { fun solution(array: IntArray, commands: Array&lt;IntArray&gt;): IntArray { var answer = intArrayOf() commands.forEach { answer += array.sliceArray((it[0] - 1) until it[1]).apply { sort() }[it[2] - 1] } return answer }} 여기서 python의 list comprehension이 떠올라서 다시 코드를 짜봤습니다. 2번 코드1234class Solution { fun solution(array: IntArray, commands: Array&lt;IntArray&gt;): IntArray = commands.map { array.sliceArray((it[0] - 1) until it[1]).apply { sort() }[it[2] - 1] }.toIntArray()} 끔찍한 원라이닝 이번엔 map기능을 이용하여 짜봤습니다! 문제는 금방 풀렸지만 python의 list comprehension과 유사한 동작을 할 수 있는 방법을 찾아서 좋았습니다! 출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges","link":"/2020/03/04/kth-number/"},{"title":"[Level 1] 프로그래머스 탐욕법 체육복 kotlin 풀이","text":"탐욕법! 프로그래머스 “모의고사” 문제를 풀어보자 문제 소개이번에 풀어볼 문제는 프로그래머스 사이트의 코딩테스트 연습문제중 Level-1에 있는 체육복이라는 문제인데 카테고리가 탐욕법(Greedy)으로 되어있다. 체육복이 없는 학생에게 체급이 비슷한 바로 주변 번호의 학생들이 체육복을 빌려줘서 체육수업을 들을 수 있는 최대 학생수를 구하는 문제입니다. n lost reserve return 5 [2, 4] [1, 3, 5] 5 입출력 예시를 봅시다!5명의 학생이 있는데 2, 4번은 체육복이 없고, 1, 3, 5번은 체육복이 남는다고 합니다. 알기 쉽게 여분을 가져온사람 : 1 딱 하나만 가져온 사람 : 0 체육복이 부족한 사람 : -1 라고 표기한다고 생각하면 [1, -1, 1, -1, 1] 이 되겠네요 당연히 전체 체육복은 다 갖고 1개가 남겠네요. 이떄 1번과 3번이 우측에 주거나([0, 0, 0, 0, 1]) 3번과 5번이 좌측에 주는경우([1, 0, 0, 0, 0]) 모두 수업에 참여할 수 있어서 5명이 답이 되는겁니다! 문제풀이중복 제거이 문제는 주의사항을 보면 특이하게도 여분을 가져왔으나 도난을 당한 경우가 있다고합니다. 여분을 가져오고(+1) 도난을 당하면(-1) 그냥 자신의 것만 가져온 학생이 되기 때문에 먼저 두 배열의 중복요소를 제거해야합니다. 먼저 python에서 set끼리 - 연산을 하는것에서 착안해서 operator funtion을 이용해서 kotlin에서도 비슷한 느낌으로 쓸 수 있게 연산자 오버로딩 함수를 만들어봤습니다. 12operator fun IntArray.minus(arr: IntArray): MutableList&lt;Int&gt; = this.filter { it !in arr }.toMutableList() 배열1 - 배열2 을 하게되면 배열1의 요소가 배열2에 들어있다면 제거해서 반환을 해줍니다. 차집합인 셈이죠! [1, 2, 3] - [1, 2] -&gt; [3] 함수도 만들었으니 처음에 입력받은 두 배열에 적용해봅시다. 12val nLost = lost - reserveval nReserve = reserve - lost 꽤나 간단하고 직관적으로 작성된 것 같습니다. 탐욕법이란?탐욕법 카테고리의 문제니 탐욕법을 우선 알아봅시다. 탐욕법은 간단히 말해서 이런 트리가 있고 여기서 최대의 합을 구하는 문제라면 완전탐색으로 모든 경우를 확인한 후 1 - 5 - 100을 선택하겠지만 탐욕법으로 해결하면 1 만을 기준으로 바로 다음에 오는 요소만 비교하여 12를 고르고 이번엔 12를 기준으로 15를 내놓게 되는데 이렇게 순간순간마다 최적이라고 생각되는 결정을 하는 방식으로 진행하여 최종 해답에 도달하는 문제 해결 방식을 탐욕법(Greedy Algorithms) 이라고 합니다! 최적 해답을 찾지는 못하지만 완전탐색에 비해 실행속도가 굉장히 빠르다는 장점이 있습니다.(사용하는곳에 따라서 다른데 수학적으로 증명하더라고요) 탐욕법으로 풀기!우리는 여분을 가져온 사람 배열의 좌측(앞)부터 차례대로 반복을 하면서 좌측을 먼저 확인해서 가져오지 않은 학생이 있다면 체육복을 줍니다. 이때 좌측에는 체육복이 없는 학생이 없는데 우측에 체육복이 없는 학생이 있다면 우측으로 줍니다. 이렇게 지금 루프를 돌고있는 요소만을 기준으로 생각해서 탐욕적으로 풀이를 하면 됩니다. 체육복을 받은 학생은 배열에서 제거해버리면 마지막에 체육복이 없는 학생 배열의 크기가 곧 체육복이 없는 학생의 수가 되니까 전체 학생수 - 체육복이 없는 학생 배열 = 체육복이 있는 학생 수 가 되어서 정답이 되겠네요! 123456nReserve.forEach { when { it - 1 in nLost -&gt; nLost.remove(it - 1) it + 1 in nLost -&gt; nLost.remove(it + 1) }} 이렇게 반복을 돌면서 배열을 조작하고 1return n - nLost.size 으로 제출하면 풀이가 끝납니다! 정답 코드123456789101112131415161718class Solution { fun solution(n: Int, lost: IntArray, reserve: IntArray): Int { val nLost = lost - reserve val nReserve = reserve - lost nReserve.forEach { when { it - 1 in nLost -&gt; nLost.remove(it - 1) it + 1 in nLost -&gt; nLost.remove(it + 1) } } return n - nLost.size } operator fun IntArray.minus(arr: IntArray): MutableList&lt;Int&gt; = this.filter { it !in arr }.toMutableList()} 이번 문제를 풀면서 탐욕법이 무엇인가 알 수 있어서 좋았고 깔끔하게 풀려서 좋았어요! 출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges","link":"/2020/03/03/programmers-gym-suit/"},{"title":"텐서플로우 &amp; 파이썬 환경 구축하기","text":"파이썬과 텐서플로우를 사용할 수 있는 환경을 구축해보자 본 글은 학교 동아리용으로 작성된 관계로 Anaconda를 이용하지 않습니다 개발 환경 소개이번에 구축할 개발 환경은 텐서플로우(Tensorflow)와 파이썬(Python)을 이용합니다. 파이썬은 1991년 프로그래머인 귀도 반 로섬이 발표한 고급 프로그래밍 언어로, 플랫폼 독립적이며 인터프리터식, 객체지향적, 동적 타이핑 대화형 언어입니다. 파이썬은 방대한 라이브러리를 지원하여 높은 생산성과 빠른 개발 속도를 가진것이 특징입니다. 텐서플로우 는 구글에서 지원하는 파이썬 환경에서 딥러닝과 같은 인공지능 기법들을 쉽게 구현하도록 도와주는 오픈소스 라이브러리입니다. 텐서플로우는 계산 구조와 목표 함수만 정의하면 자동으로 미분 계산을 처리해줘 매우 편리합니다. 파이썬 설치 그럼 바로 Python부터 설치해봅시다. 먼저 https://www.python.org/downloads/windows/ 에 들어갑니다. 여러 가지 버전 중 자신의 컴퓨터에 해당하는 버전을 설치해봅시다. 저는 여기에서 윈도우 Windows x86 executable installer버전을 설치하겠습니다. 이때 여기에서 Add Python {version} to Path 를 꼭 체크해주세요!! 이를 체크해야 환경 변수에 파이썬 경로가 추가되어서 어떤 곳에서 나 python을 사용할 수 있습니다. 설치가 되었다면 Window + R을 눌러 명령 프롬프트(CMD)창을 실행시켜줍니다. 그 다음 python을 입력하여 잘 작동하는지 확인하고 창을 닫아줍니다. 여기서 Python을 찾을 수 없다는 메시지가 뜨면 아까 설치 과정에서 Add Python {version} to Path 를 체크하지 않아서 환경 변수에 추가가 안된 경우입니다. 그럴 경우 다시 설치 파일을 실행시켜 파이썬을 제거 후 위의 파이썬 설치 과정을 다시 진행하면 됩니다. 텐서플로우(Tensorflow) 설치다시 Window + R을 눌러 명령 프롬프트(CMD)창을 실행시켜줍니다. 먼저 pip3 install --upgrade pip로 pip를 업그레이드 해준 후 pip3 install tensorflow를 입력하여 텐서플로우를 설치해줍니다. 여기서 pip는 파이썬으로 작성된 패키지 소프트웨어를 설치 &amp; 관리하는 패키지 관리 시스템을 말합니다. 이제 python을 입력하여 파이썬 커멘드(Command) 라인으로 들어가줍니다. 한번 잘 작동하는지 아래의 코드를 입력하여 테스트를 해봅시다. 123import tensorflow as tfhello = tf.constant('Hello World!')sess = tf.Session() 이 스크린샷처럼 I tensorflow/core/platform/cpu_feature_guard.cc:141] Your CPU supports instructions that this TensorFlow binary was not compiled to use: AVX2 와 같은 오류가 뜰 수 있는데, 이는 직역하면 당신의 CPU는 이 텐서플로우 바이너리가 사용하지 않은 명령어(instructions)들을 지원한다. 라는 뜻으로 실행 속도를 더 개선시킬 수 있으므로 컴파일 옵션을 최적화하라는 경고 메시지이므로 무시하고 넘어갑니다. 경고 상세 설명 최신 CPU들은 AVX, SSE4 같은 명령어들을 제공합니다.이 명령어들은 CPU가 선형대수(Linear Algebra) 연산을 좀 더 빠르게 수행할 수 있도록 도와주는 역할을 합니다.머신러닝에서 학습 동작은 이런 선형대수 연산을 사용하기 때문에 선형대수 연산의 속도 개선은 학습 속도 개선으로 이어지게 되는 것입니다.이런 CPU Instruction을 이용할 경우 학습 속도가 300%까지 빨라질 수 있다고 합니다. (해결법 및 설명 원문 : https://stackoverflow.com/questions/47068709/your-cpu-supports-instructions-that-this-tensorflow-binary-was-not-compiled-to-u) 그다음 이어서 print(sess.run(hello))를 입력하여 아까 얻어온 세션의 값을 콘솔 창에 출력해 봅시다. 위 사진과 같이 b'Hello World!'가 출력되는 것을 볼 수 있습니다. 여기서 b는 자료 구조와 관련된 키워드이므로 지금은 넘어가도록 하겠습니다. 이렇게 파이썬과 텐서플로우 설치를 마치도록 하겠습니다!!","link":"/2019/05/25/tensorflow-development-environment/"},{"title":"2020년, 회고와 새해 다짐","text":"한게 정말로 없지만 뭐라도 써보자 2019년에 뭐 했더라1. 학교생활2019년이 한건 없는데 막 지나갔습니다공부한답시고 프로그래밍을 반정도 놓으려고도 했었는데 안하고는 못 버틸것 같아서 가끔씩 깨작거렸습니다.공부도 놓쳤고 프로그래밍도 딱히… 그래도 빅데이터 동아리 회장, 아두이노 자율동아리, 학술제 같은 학교 활동들을 주기적으로 했고학교의 모든 발표에 꾸역꾸역 프로그래밍을 넣어서 뭔가 조금씩 잊지 않으려고 한 2019년이었던 것 같습니다. 어쩌다보니 동아리 규모도 꽤 커져서 약 40명을 수용하게 되었네요. 2. 인공지능사실 저는 인공지능의 매우 일부분, 기초중 기초만을 알고있습니다.인공지능에 처음 관심을 갖게된 것은 하이톤(고등학생 해커톤)에서 옆팀에 계시던 분께서 머신러닝과 음성인식 기술을 활용하여 멋진 응급상황 대처 앱을 제작하신게 굉장히 인상깊고 힙해서 바로 도서관으로 달려가서 책을 알아봤습니다. 다행히 저희 동네는 4차산업특화(?)같은 신도시라서 그런지 동네 도서관에 IT서적이 몰려있는 특화 코너가 있어서 어렵지 않게 찾아볼 수 있었습니다. 그중 제일 눈에 띈 책이 골빈해커의 3분딥러닝 - 김진중(골빈해커)였습니다! 우선 다른 책에 비해서 책의 크기가 조금 작고, 센스있는 제목과 표지가 있어서 읽기 편했습니다. 대략적인 작동방식, 대표적인 모델등을 이런 책과 구글링을 통해서 습득했습니다. 지금 생각하면 멍청한 질문을 골빈해커님께 DM으로 보냈었던 기억이나네요 그 후 환경을 구축해가며 아까 위에서 서술했던 빅데이터 동아리에서 간단한 예제를 돌려보려고 수업 자료로 쓰려고텐서플로우 &amp; 파이썬 환경 구축하기를 작성했습니다. 그러다가 결국 학교 학술제 발표에서 Keras로 LSTM으로 시를 짜주는 인공지능을 만들어보게되었습니다!Char-RNN-LSTM-using-Keras관련된 글은 나중에 작성해보겠습니다! 나름 만들고 뿌듯했지만 발표시간이 작아서 아쉬웠던것 같습니다. 3. 안드로이드 앱사실 이게 메인이었습니다. 초등학교때 야매로 프로그래밍이 뭔지도, 변수가 뭔지도 모르고 제대로된 문서 없이 네이버 카페에 의존하다가 Kotlin을 배우면서 문서를 읽으면서 제대로 배우기 시작한 것 같습니다. Native Android를 어느정도, 초보를 갓 벗어난 수준으로 다룰 수 있게 되었지만, 여러가지 학교 활동에 치어서 별로 만든건 크게 없었고 현재 참여하고 있던 프로젝트인 FoodViewer에 사용될 라이브러리와 샘플 프로젝트를 만들어뒀습니다. 정확히는 구글 min3D가 현재 안드로이드 프로젝트 구조와는 완전 동떨어져있고, 제대로된 샘플도 없었기에 나중에 클라이언트 단에서 .obj 파일을 불러와서 여러가지에 활용하기 위해서 모듈 라이브러리화를 시키고, TextureView 와 엮어서 뭔가 AR처럼 띄워보기도 했습니다. 4. 파이썬이번년도에 제일 많이 만진게 뭐냐! 라고 누가 묻는다면 저는 망설임 없이 “파이썬을 했다!” 라고 답할 것 같습니다. 가장 기억에 남는 일은 물리 발표인데요 그래서 블럭들이 충돌하는 횟수가 왜 원주율에 가까워질까요?이 영상을 보고나서 당장 미리 설치해둔 Unity를 키고 같은 상황을 만들어서 실험을 해봤습니다. 하지만 1kg, 10000kg 부터는 문제가 발생하였습니다.유니티 엔진의 고질적인 문제 때문인것 같습니다. 그래서 PyGame을 이용하여Python3-2D-Elastic-Collision를 만들어 본 결과 성공을 했고 이것으로 발표를 했습니다 이것 뿐만이 아니라 학교에서 매주 화요일마다 파이썬 수업을 받아서 틈틈히 코드를 짰었고, 빅데이터 동아리에서도 갓갓 외부 강사님을 모셔와서 파이썬으로 수업을 진행해서 진짜 파이썬을 제일 많이 사용했네요! 5. 아희아희 는 제가 제일 애착이 많이 가는 언어중 하나입니다! 어느 날 카톡방에서 어떤분이 아희라는 언어가 있다고 같이 공부해보지 않겠냐고 해서 같이 공부하다가, 한글을 이렇게 놀랍도록 활용하여 사용할 수 있구나하고 빠져들게 되었습니다 이 앱 프로젝트는 사실 핸드폰에서 아희를 편하게 돌려보려고 만들었는데 생각보다 저만편하게 쓰고있었습니다. 나중에는 인터프리터도 직접 Kotlin으로 짜는것이 목표입니다.만들게되면 Kotlin/Aheui로 배포할 것 같네요 예전에 오픈 채팅방에서 제 앱을 통해서 아희코드를 생성해서 쓰고 계신분을 보고 너무 뿌듯해서 그 때부터 아희를 전파(?)하고 다니게 된 것 같습니다. 이 코드도 AheuiRo로 제작하였으니 관심있는 분들은 다운 받아보시는걸 추천해드립니다.아희를 전혀 몰라도 3초면 제작할 수 있어요! 6. 그 외의 나머지 것들이번년도에는 Node.js를 이용해서 매우 간단한 백엔드를 짤 수 있게 되었고, 프론트엔드는 HTML 으로 매우 조금 간단한 페이지를 짤 정도로 잠깐 배웠던 것 같아요. 마크업 언어라고는 Android Xml 만 다루다가 HTML 을 배워보니 어렵더라고요. 생각보다 정리해보니 매우 다양한 경험, 활동을 한 것 같기도 합니다. 2020년 계획과 목표1. 학교 생활에 충실하기이건 어떻게 보면 2019년에 제일 못 지킨 것 같습니다… 이번엔 꼭 반성하고 열심히 공부해야 대학가죠 근데 아마 2020년에도…… 2. 프로그래밍 관련 글 포스트하기지금까지는 안해봤던 새로운 목표인데요! 사실상 프로그래밍을 붙잡고 하기는 시간상 힘들 것 같고, 블로그도 만든김에 가끔 글을 써보려고 합니다. 3. 잠좀 제시간에 자고 운동 가끔하기네.. 중학교때부터 집돌이로 살아서 운동은 거의 해본적이 없습니다 그러다보니 체력적인 면도 조금 부족한 것 같고 특히 잠을 너무 자유분방하게(?)자다보니까 체력이 팍팍 닳은 것 같아요.. 그러니까 제발 이번년도에는 잠 제때 자기!! 어찌되었던지 결국 2020이고 2021 수능이 다가오네요! 모두 새해 복 많이 받으시고 커밋 열심히 하시길!!","link":"/2020/01/01/happy-new-2020/"},{"title":"[Level 1] 프로그래머스 나누어 떨어지는 숫자 배열 코틀린 풀이","text":"프로그래머스 나누어 떨어지는 숫자 배열 코틀린 풀이! 문제 소개이번 문제는 수를 다루는 연습문제입니다. 이번 문제는 배열과 나눌 수를 주고 나누어지는 수만 필터링하는 문제입니다!특이한 점은 정수 i, j에 대해 i ≠ j 이면 arr[i] ≠ arr[j] 입니다.라는 조건에서 알 수 있듯이 중복이 없고 아무것도 나누어 떨어지지 않는다면 배열에 -1을 담아 반환해야한다는 점입니다. 문제풀이나머지가 0이면 나누어 떨어지겠죠? 먼저 받아온 array를 나누어 떨어지는지로 필터링한 후 정렬해줍니다. 1arr.filter { it % divisor == 0 }.sorted() 근데 우리는 나누어 떨어지지 않을 때 -1을 넣어야하니 수정 가능한 리스트로 바꿔줍시다. Kotlin의 List는 기본적으로 변경 불가능(Immutable)합니다. 1234arr.filter { it % divisor == 0 }.sorted().toMutableList().run { if (size == 0) add(-1) toIntArray() } size가 0일때 -1을 추가해주고 정답형태인 IntArray로 변형해줍니다. 정답 코드1234567class Solution { fun solution(arr: IntArray, divisor: Int): IntArray = arr.filter { it % divisor == 0 }.sorted().toMutableList().run { if (size == 0) add(-1) toIntArray() }} 뭔가 숏코딩처럼 풀렸네요! 쉬운문제니 빨리 풀고 넘어갑시다!! 출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges","link":"/2020/03/05/dividing-sequence-of-numbers/"},{"title":"[Level 1] 프로그래머스 가운데 글자 가져오기 Kotlin풀이","text":"프로그래머스 가운데 글자 가져오기 문제 Kotlin풀이! 문제 소개문제 그냥 가운데 글자를 가져오면 된다.짝수일경우 가운데 2글자! 문제풀이1s.slice((s.length - 1) / 2..s.length / 2) 매우 간단하다 입력받은 s(String)을 자를건데 수의 특성상 1 2 3 4 5 6 7 8 9 10 ...을 각각 2로 나눈 몫을 보면0 1 1 2 2 3 3 4 4 5 ... 이 된다. 따라서 (s.length - 1) / 2 부터 s.length / 2 까지 자르면문자열이 홀수(2n + 1) 일때는 n ~ n 까지 자르게 되고문자열이 짝수(2n) 일때는 n - 1 ~ n 만큼 자르게 된다. kotlin의 / 연산자는 몫을 Int형태로 리턴한다. 정답 코드1234class Solution { fun solution(s: String): String = s.slice((s.length - 1) / 2..s.length / 2)} 쉽고 재밌는 문제였습니다! 출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges","link":"/2020/03/04/middle-char/"},{"title":"[Level 1] 프로그래머스 문자열 다루기 기본 코틀린 풀이!","text":"프로그래머스 문자열 다루기 기본 코틀린 풀이! 문제 소개이 문제는 문자열이 숫자인지 + 4글자나 6글자인지를 판별하는 쉬운 문제입니다! 문제풀이풀이방법도 간단합니다. 숫자 4글자나 6글자 이 두가지만 조건문으로 짠 뒤 &amp;&amp;(And)로 연결해주면 됩니다! 숫자 판별에는 String.toIntOrNull()을 이용할건데요 숫자로 변환이 실패하면 null을 주니 null이 아니면 숫자겠죠? 길이는 String.length이용해서 바로 판별해주면 됩니다!! 정답 코드1234class Solution { fun solution(s: String): Boolean = s.toIntOrNull() != null &amp;&amp; s.length in intArrayOf(4, 6)} Level 1 첫 페이지도 중간쯤 왔네요!! 파이팅! 출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges","link":"/2020/03/05/string-handling-basics/"},{"title":"[Level 1] 프로그래머스 문자열 내림차순으로 배치하기 코틀린 풀이","text":"프로그래머스 문자열 내림차순으로 배치하기 코틀린 풀이! 문제 소개이 문제는 주어진대로 정렬을 하라는 문제군요! 조건을 잘 읽고 바로 풀어봅시다! 문제풀이 s return Zbcdefg gfedcbZ 요걸 보면 소문자역순으로 배치하고 대문자를 역순으로 배치하는데 이를 쉽게 생각해보면 대문자를 정순으로 배치, 소문자를 정순으로 배치하고 통째로 뒤집으면 된다는 소리입니다! String을 .toList()를 통해서 글자별 배열로 쪼갠후 .sorted()를 통해서 정렬하여 가져옵니다. 그다음 뒤집고 .reversed() .joinToString()하면?,가 섞여나옵니다… .joinToString()의 seperator를 공백(&quot;&quot;)으로 맞춰줘야합니다! 그럼 끝! 정답 코드1234class Solution { fun solution(s: String): String = s.toList().sorted().reversed().joinToString(separator = \"\")} sort, reverse, joinToString등등 내장함수 너무 편해요… 출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges","link":"/2020/03/05/string-descending-sort/"},{"title":"[Level 1] 프로그래머스 2016년 Kotlin 풀이","text":"프로그래머스 “2016년” Kotlin 풀이 문제 소개이번 문제는 병신년(丙申年) 문제입니다! 월, 일을 입력받아서 2016년의 무슨 요일인지를 출력하는 문제군요! 문제풀이풀이도 매우 간단합니다. 우선 2016년의 총 날짜들을 배열로 담아줍니다.이때 윤년이기 때문에 2월은 29일로 칩니다! 1val year2016 = listOf(31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31) 그 다음은 월화수목금토일을 문제에서 요구하는 형태로 배열에 담아줍니다. 2016년 1월 1일은 금요일이어서 0번째에 FRI를 넣을 것 같지만이때 zero-based-indexing을 고려해서 저희는 배열의 1번째에 FRI를 담아줍니다! 1val dayOfWeek = listOf(\"THU\", \"FRI\", \"SAT\", \"SUN\", \"MON\", \"TUE\", \"WED\") 이제 할 일은 간단합니다. 5월 24일이라면 1월 + 2월 + 3월 + 4월 + 24일이므로 1월 부터 4월까지의 총 날짜들을 모두 더한 후 24를 더해주면 지금까지가 2016/01/01로 부터 몇일인가를 알 수 있겠죠! 저는 range.map을 이용하여 구현해봤습니다. 1val totalDay = (0 until a - 1).map { year2016[it] }.sum() + b 이제 totalDay를 7로 나눈 나머지로 datOfWeek에서 꺼내오면 끝! 1dayOfWeek[totalDay % 7] 정답 코드123456789class Solution { fun solution(a: Int, b: Int): String { val dayOfWeek = listOf(\"THU\", \"FRI\", \"SAT\", \"SUN\", \"MON\", \"TUE\", \"WED\") val year2016 = listOf(31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31) val totalDay = (0 until a - 1).map { year2016[it] }.sum() + b return dayOfWeek[totalDay % 7] }} 요일 계산을 직접 구현해본건 처음이라 재밌었습니다! import java.util.Calendar 필요 출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges","link":"/2020/03/04/year2016/"},{"title":"[Level 1] 프로그래머스 수박수박수박수박수박수? 문제풀이 🍉👏","text":"🍉👏🍉👏🍉👏🍉👏🍉👏🍉👏🍉👏🍉👏🍉👏🍉👏 문제 소개이 문제는 수박수박수박수...를 출력하면 되는 문제입니다! 문제풀이처음에 10000자 이하라는것을 보고 10000자짜리 수박수박수를 만든 후 자르려고 했다가 정신 붙잡고 다시 코드를 짰습니다! 방법은 간단합니다 반복 돌면서 [&quot;수&quot;, &quot;박&quot;]에서 번갈아 꺼내면 되는거죠! 짝홀을 이용하면 번갈아서 꺼낼 수 있을 것 같습니다!! joinToString에 mapping기능이 같이 붙어있길래 어짜피 String제출이니 map 대신 써봤어요! 바로 정답 코드 보시죠 정답 코드1234class Solution { fun solution(n: Int): String = (0 until n).joinToString(separator = \"\") { arrayOf(\"수\", \"박\")[it % 2] }} 수박이냐 박수냐 그것이 문제로다 :thinking: 출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges","link":"/2020/03/05/watermelon-or-clap/"},{"title":"[Level 1] 프로그래머스 서울에서 김서방 찾기 코틀린 풀이","text":"프로그래머스 서울에서 김서방 찾기 코틀린 풀이 문제 소개이번 문제는 집나간 김서방을 찾아오는 문제입니다! index 서칭하면 끝나네요 문제풀이Linear Searching이고 뭐고 많은 서칭법이 있지만 킹갓코틀린에는 .indexOf라는 내장함수가 있습니다! 쉽게 끝! 정답 코드1234class Solution { fun solution(seoul: Array&lt;String&gt;): String = \"김서방은 ${seoul.indexOf(\"Kim\")}에 있다\"} 쉬운 문제네요! 직접 for문 돌면서 구현해도 재밌을것 같아요! 출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges","link":"/2020/03/05/find-kim-in-seoul/"},{"title":"Github Page와 Hexo로 블로그 만들고 테마 적용하기 + 검색엔진 최적화(SEO)","text":"Github Page와 Hexo로 1시간만에 블로그 만들기 + 테마 설치 깃헙 설치, 플러그인 설치, 검색엔진 최적화, rss 까지! 간략한 소개이번 포스팅에서는 GitPage와 Hexo 프레임워크를 이용해서 개인 블로그를 손쉽게 만드는 방법을 소개해드리려고합니다! Github Page: https://pages.github.com/ Hexo: https://hexo.io/ 지금 읽고계신 저의 블로그도 GitPage와 Hexo 그리고 Icarus 테마로 만들어졌는데요 GitPage는 정적 페이지를 username.github.io로 쉽게 호스팅하도록 도와줍니다! Hexo는 정적 페이지를 쉽게 만들 수 있도록 도와주는 블로그 프레임워크입니다! hexo의 장점으로는 npm(node package manager)를 통해 간단히 설치 가능 Node.js기반으로 매우 빠른 생성 속도를 제공합니다. 다양한 플러그인을 지원 Markdown의 모든 기능을 지원등이 있겠네요 그럼 차근차근 한단계씩 만들어봅시다! GitHub 사용하기가입 및 정적 페이지 호스팅Gitpage를 사용하기 위해서는 우선 Github에 가입이 되어있어야합니다! 깃허브로 들어가셔서 가입 버튼을 누른후 회원가입을 우선 진행해줍니다! 그 다음 새로운 repository를 만들어주기 위해서 new 버튼을 누릅니다! 누르면 새로운 레포를 생성하는 창이 뜨는데요. Repository name에는 깃헙아이디.github.io를 입력해주시고 기본값인 Public으로 두고 Create repository를 눌러서 레포를 생성해줍니다! 여기까지 하셨다면 절반은 성공했습니다! 정적 페이지 테스트이번엔 아까 설치한 Gitpage의 기능을 테스트해보면서 Git을 설치하고 이용해볼건데요. 이미 나는 Git을 사용중이다, 사용방법을 알고있다 하시는 분들은 넘어가셔도 좋습니다! Git 설치저희는 Github를 이용하기 위해서 Git을 설치하고 이어서 진행할겁니다. Git 설치 여기서 받으시고 next를 눌러 기본 옵션으로 설치해줍니다! 곧 Git 설치법 글로 자세히 설명하겠습니다 CMD로 폴더 선택먼저 테스트를 위해서 새로운 빈 폴더를 하나 만들어줍시다! 저는 test라고 이름을 지었고 제 폴더 경로는 E:\\Project\\GitPage\\test입니다! 이번엔 CMD(명령 프롬프트)를 열건데요 윈도우키 + R을 한 후 cmd라고 입력하시면 검은 창이 뜰겁니다! 여기 보시면 저는 지금 C:\\Users\\ghdtj 폴더가 선택되어있습니다.하지만 저흰 아까 만든 프로젝트로 이동해야합니다! 먼저 드라이브가 바뀌니 E:를 입력해줍니다! 그 다음 cd 아까 경로를 입력해줄건데요.저같은 경우는 cd E:\\Project\\GitPage\\test가 되겠네요! 정적 페이지를 호스팅해보자현재 github에 올라가있는 초기 셋팅을 내 컴퓨터(로컬)로 옮겨봅시다! Clone the repository아까 열고 이동한 cmd에 아래의 커맨드를 입력합시다. 꼭 username 자리에 본인의 깃허브 아이디 입력! 1$ git clone https://github.com/username/username.github.io Hello World그 다음 이 두줄을 순서대로 입력합시다.cd로 해당 폴더로 이동, 그 아래 커맨드로 테스트를 위한 index.html 파일을 만들어줍니다! 123$ cd username.github.io$ echo \"Hello World\" &gt; index.html 여기도 꼭 username 자리에 본인의 깃허브 아이디 입력! Push it!마지막으로 다시 깃헙으로 프로젝트를 넘겨줄 차례입니다!마찬가지로 차례대로 진행해주세요! 12345$ git add --all$ git commit -m \"Initial commit\"$ git push -u origin master …and you’re done!브라우저를 열고 https://&lt;자기아이디&gt;.github.io로 들어가보세요!Hello World가 써있는 페이지가 뜨면 성공입니다! Hexo 설치이제 저희는 Hexo를 설치해볼겁니다!아까 말씀드렸듯이 Hexo는 Node.js기반이라 npm을 통해서 간편하게 설치할 수 있습니다! node.js 설치이미 Node.js가 설치되어있어 npm 사용이 가능하신분들은 넘어가셔도 좋습니다! https://nodejs.org/en/으로 들어가서 노드 LTS버전을 설치해줍니다! 여기도 마찬가지로 따로 건들 항목은 없고 next만 눌러주시면 설치가 간편히 끝납니다! Hexo 클라이언트 설치Hexo를 사용하기 위해서는 우선 npm에서 hexo 클라이언트를 받아와야합니다! CMD를 열고 1$ npm install hexo-cli -g 라고 입력해주면 됩니다! hexo 블로그 폴더 생성이번에는 123$ hexo init blog$ cd blog$ npm install 를 입력해서 blog라는 이름의 hexo폴더를 만든 후,폴더를 선택하고 npm을 설치합시다! 이렇게 되면 성공입니다! 블로그 기본 정보 수정방금 생성한 blog폴더를 열어보시면 _config.yml라는 파일이 생겨납니다! https://hexo.io/docs/ 에서 다양한 옵션을 볼 수 있습니다! 파일을 열어서 내용을 수정해봅시다! site 기본 정보 수정12345678# Sitetitle: Hexosubtitle: ''description: ''keywords:author: John Doelanguage: entimezone: '' 를 찾아서 원하시는대로 수정해주시면 됩니다! 저같은 경우는 123456789# Sitetitle: Kinetic's BLOGsubtitle: '키네틱의 블로그'description: '키네틱의 블로그입니다'keywords: programming, aheui, kotlin, androidemail: ghdtjrwls27@gmail.comauthor: Kinetic27language: kotimezone: 'Asia/Seoul' 으로 수정했네요! URL 정보 수정바로 아래에서 url 셋팅을 찾아서주세요! 12345678# URLurl: http://yoursite.comroot: /permalink: :year/:month/:day/:title/permalink_defaults:pretty_urls: trailing_index: true trailing_html: true 라고 되어있는데요, 여기서 url에 자신의 깃허브 유저명을 넣어서 http://username.github.io을 넣어주시면 됩니다! 저는 이렇게 수정해봤습니다! 12345678# URLurl: http://kinetic27.github.ioroot: /permalink: :year/:month/:day/:title/permalink_defaults:pretty_urls: trailing_index: true trailing_html: true Deploy 설정쭉 내리시면 123# Deploymentdeploy: type: '' 가 보일텐데요! 저희는 이 항목을 자신의 Gitpage Repository 정보를 넣어서 수정할겁니다! 여기도 username 바꿔주세요! 12345# Deploymentdeploy: type: git repo: https://github.com/username/username.github.io.git branch: master hexo 테스트여기까지 오셨다면 기본적인 설정이 완료된겁니다! 🎉🎉 이제 프로젝트 폴더로 이동해둔 CMD를 다시 열고,아래의 커맨드를 입력하면 로컬에서 테스트가 가능합니다! 1$ hexo server hexo server는 줄여서 hexo s로도 사용가능합니다! 서버가 열렸다는 문구가 명령창에 뜨면 웹 브라우저를 열고 http://localhost:4000로 들어가서 블로그를 볼 수 있습니다! Github에 배포하기이제 방금까지 만든 헥소 블로그를 깃허브로 배포해봅시다! 로컬에서 열면 자기 컴퓨터에서만 보이니까요! 아까 CMD창을 다시 열어줍니다.혹시 닫으셨다면 다시 CD명령어로 blog폴더까지 들어가주시고요. 아래의 두 명령어를 입력해서 생성, 배포를 해주세요 Hexo를 이용해 정적 웹 리소스 생성하기1$ hexo generate 줄여서 hexo g로도 사용가능합니다! github에 배포하기1$ hexo deploy 줄여서 hexo d로도 사용가능합니다! 이 두가지를 합쳐서 hexo generate -deploy 혹은 hexo g -d로 사용가능합니다!! 혹시 배포시에 ERROR Deployer not found: git 라는 에러가 뜬다면 1npm install hexo-deployer-git --save 를 통해서 플러그인을 설치해주세요! 여기까지 하셨다면 다시 https://username.github.io로 들어가보시면 hexo페이지가 보일겁니다!! 🎉🎉🎉 테마 설치법hexo에는 사용자가 다운받아서 적용할 수 있는 수많은 테마들이 존재합니다! 링크를 타고 들어가셔서 테마를 고른다음해당하는 테마의 이름 부분을 누르시면 해당 테마가 올라가져있는 github이 열리는데요! 디자인, 반응형, 영문메뉴얼유무를 잘 따져보도록합시다! 각 테마가 시키는대로 설치하면 됩니다! 공통점은 1$ git clone [테마에 링크 써있는거.git] themes/테마이름 방식으로 clone해서 설치하고_config.yml에 들어가서 theme: 테마이름으로 수정해줘야합니다! 그다음 hexo g 명령어를 사용하면 테마 폴더 안에 _config.yml가 하나 더 생길텐데 이것으로 테마의 제목, 내용 등을 수정할 수 있습니다! 고치고 hexo g, hexo s를 통해서 반영되었는지 확인해봅시다! 참고로 제가 쓰고있는 테마는 Icarus라는 테마입니다! Icarus: https://github.com/ppoffice/hexo-theme-icarus.git 앗 작동이 안됩니다!실행시 1ERROR: pakage [이름] is not installed. 에러가 뜨는 경우가 있습니다. icarus 테마 설치시에는 cheerio 에러가 뜨는데요.이럴때는 1$ npm install [이름] --save 명령어를 통해서 없는 패키지를 모조리 설치합시다! 테마를 바꿨는데 적용이 안됩니다!그럴때는 1$ hexo clean 을 사용해서 초기화를 해준 후 다시 1$ hexo g 를 해줍시다! 블로그 홈의 로고등 이미지 변경이미지 변경법은 간단합니다.해당 테마 폴더의 source/images에 이미지를 넣어주고 logo: /images/logo.svg와 같이 기존의 이미지를 대체하도록 수정하면됩니다. 꿀팁, submodule사용해서 테마 관리테마를 다른 github 레포에서 관리하는 방법이 있습니다!내 저장소의 특정 subdirectory에 다른 Git저장소를 연결해서 사용하는 방식인데요.쉽게 생각하면 레포안에 레포를 import한 느낌입니다. 방법은 간단합니다. 위에서 소개한 방법을 이용하는 대신 명령어가 바뀝니다 1$ git clone [테마에 링크 써있는거.git] themes/테마이름 대신에 1$ git submodule add [테마에 링크 써있는거.git] themes/테마이름 를 해줍니다! 그다음 똑같이 _config.yml의 theme:를 수정한 후 hexo g로 생성해줍니다! 나중에 다른 환경에 자신이 만든 저장소를 클론해야 할 일이 생길 텐데 단순히 클론만 받으면 하위 경로에 있는 submodule까지 클론이 되지 않습니다! 이럴때는 이 명령어로 해결합니다! 1$ git submodule update --init --recursive 꿀팁, README.md 넣기헥소에서 리드미를 넣어주려고 source_dir에 파일을 넣어줬더니 hexo g를 하면 public_dir에 README.html로 변환되어서 들어간다… 해결방법은 간단합니다! 요렇게 skip_render 속성을 주시면 됩니다! 폴더 단위로도 사용이 가능하니 참고하세요! Icarus테마 꿀팁About 페이지테마 설치하고 돌렸는데 Cannot GET /about/이라면서 about 페이지만 안떠서 불편하셨죠? 이럴떄는 프로젝트의 source에 about 폴더를 만들고 그 안에 index.md를 추가해보세요! 간단하게 123456789101112---layout: abouttitle: About Kineticdate: 2019-12-27 03:56widgets: - type: recent_posts position: right---## Intro.안녕하세요. 요런식으로 적고 hexo g, hexo s해서 보면 에러가 사라지고 보일겁니다! 포트폴리오 적기에 안성맞춤이네요! OG image 설정법OG이미지란 링크를 보내면 읽어서 띄워주는 미리보기 같은건데요. 이를 설정하기 위해서는 크게 두가지 방법이 있습니다. source 폴더 안에 images 폴더를 만들고 og_images.png라는 이름으로 넣어줍니다. hexo의 _config.yml에 가서 article: 하위에 og_image: &quot;이미지경로&quot;의 형태로 추가한다. 두가지 방법 모두 post.js안에 이렇게 정의되어있어서 혹시나하고 해봤더니 모두 html head에 잘 반영되는것을 볼 수 있다. 새 글 쓰는법관련 포스트는 추후 작성될 예정이지만 간단히 소개해드리면 cmd를 열고 1$ hexo new [레이아웃명] [새 포스트명] 을 입력하면 source/_posts 폴더에 새 md가 생길겁니다! 레이아웃명은 post가 default라서 생략가능합니다! 이제 Markdown 형식을 가지고 글을 쓰면 됩니다! 바로 발행되지 않는 글을 쓰고싶다면 레이아웃명에 draft를 적으면 되겠네요! 그후 발행시에는 1$ hexo publish [포스트명] 로 draft에서 publish해줍니다! 마크다운 관련 포스트는 추후 작성될 예정입니다! 유용한 플러그인 설치12Icarus 테마 3.0 유저는 jsx기반이니 아래의 방법대로 사용이 불가능한 플러그인들이 있습니다그 경우에는 테마를 https://github.com/imaegoo/hexo-theme-icarus/tree/night 로 교체해주세요(Icarus 2.0) SEOSEO란?:영어로 Search Engine Optimization로 대부분 검색엔진 최적화(SEO)와 관련되어있어요! 플러그인 설치와 삭제설치 npm install –save 삭제 npm uninstall hexo-autonofollow이 플러그인은 rel=&quot;external nofollow&quot;속성을 자동으로 추가하여 외부 링크 크롤링을 막아준다! 1$ npm install hexo-autonofollow --save _config.yml 수정 12345nofollow: enable: true exclude: - exclude1.com - exclude2.com hexo-auto-canonical이 플러그인은 대표 URL 지정을 돕는다! 1npm install --save hexo-auto-canonical head.ejs 안에 코드를 넣어야하는데 테마마다 다르니 잘 찾아보자.icarus 테마의 경우는 icarus/layout/common/head.ejs에 위치해있다. 넣을 코드 &lt;%- autoCanonical(config, page) %&gt; 12345678910&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;meta name=&quot;generator&quot; content=&quot;&lt;%= config.title %&gt;&quot;&gt; &lt;title&gt;&lt;%= title %&gt;&lt;/title&gt; &lt;meta name=&quot;author&quot; content=&quot;&lt;%= config.author %&gt;&quot;&gt; &lt;% if (keywords) { %&gt; &lt;meta name=&quot;keywords&quot; content=&quot;&lt;%= keywords %&gt;&quot;&gt; &lt;% } %&gt; &lt;%- autoCanonical(config, page) %&gt; &lt;---- 요 한줄을 추가하면됩니다! hexo-generator-seo-friendly-sitemap이 플러그인은 더욱 효율적으로 크롤링 할 수 있도록 사이트맵 xml 파일을 자동으로 생생해줍니다! 1npm install hexo-generator-seo-friendly-sitemap --save _config.yml에 아래의 내용을 추가해줍니다! 123# sitemap auto generatorsitemap: path: sitemap.xml hexo-generator-feed 추가RSS 피드를 만들어서 일종의 블로그 구독기능을 만들어주는데요! 1npm install hexo-generator-feed --save _config.yml에 아래의 내용을 추가해줍니다! 12345# rss feed auto generatorfeed: type: rss2 path: rss2.xml limit: 20 3가지 옵션은 옵션 내용 type feed의 종류 (atom/rss2) - * 네이버는 atom을 지원하지 않음 path feed가 생성될 경로(default : atom.xml, rss2.xml) limit 최신 포스트 수 설정 (0 또는 false - 전체 포스트) 입니다! hexo-related-popular-posts1$ npm install hexo-related-popular-posts --save 으로 설치하고요 article.ejs의 맨밑에 아래 코드를 삽입합니다!&lt;%- popular_posts () %&gt; _config.yml 밑에 추가해줍니다! 123456789101112131415161718192021222324252627282930313233 # More detailed settingspopularPosts: # (optional) Popular posts options googleAnalyticsAPI: clientId: ******.apps.googleusercontent.com serviceEmail: *****@developer.gserviceaccount.com key: /hexo-project-root/path/to/google-services.pem viewId: 12345678 dateRange: 30 expiresDate: 10 pvMeasurementsStartDate: 2015/11/01 rankingSheet: rankingSheet.txt # cache: # (Deprecated) This options is Deprecated &gt; v0.1.3 # path: hexo-related-popular-posts-ga-cached.json # (Deprecated) This options is Deprecated &gt; v0.1.3 # expiresDate: 10 # (Deprecated) This options is Deprecated &gt; v0.1.3 # (optional) Advanced Related posts options morphologicalAnalysis: negativeKeywordsList: pluginSettings/hexo-rpp-negativewords.txt limit: 300 # (optional) Related post's weight options weight: tagRelevancy: 1.0 contentsRelevancy: 1.0 # (optional) Cache options (Improve generation speed.) cache: path: cache/hexo-popular-related-posts-ga-cached.json # (optional) Log options log: true hexo-generator-robotstxt자동으로 robot.txt 파일을 생성해주는 플러그인 입니다. 설치 1npm install hexo-generator-robotstxt --save _config.yml에 적용! 12345robotstxt: useragent: &quot;*&quot; allow: - / sitemap: https://username.github.io/sitemap.xml 를 추가해줍니다! hexo-asset-link이 플러그인은 필수템입니다. 1$ npm install hexo-asset-link --save 포스트의 md파일이 있는곳에 포스트의 이름과 동일한 폴더를 만들고 이미지를 넣으면 예를들어 이렇게 될텐데요 12345+-- _posts/| +-- 2019-02-14-Test-Post.md| +-- 2019-02-14-Test-Post/| +-- Test-Image.png| +-- Test-Other-File.pdf 그러면 이제 이미지에 접근할때 ![이미지 설명](Test-Image.png) 으로 간단하게 접근이 가능해집니다! 자세한 설명은 https://www.npmjs.com/package/hexo-asset-link 에서 확인할 수 있습니다! 검색엔진에 등록하기구글구글 애널리틱스(Google Analytics)에 가입을 먼저 해야합니다. 그 후 사이트 정보를 입력하고 추적 ID를 발급받습니다! _config.yml에서 plugins 항목에 google-analytics를 추가해줍니다! 1234plugins: google-analytics: # Google Analytics tracking id tracking_id: UA-*********-1 그 다음 Search Console로 들어가서 가입 후 속성을 추가해 줘야합니다. 인증 방법은 두가지로 생성된 html파일을 루트에 올린 후 확인 하는 방법과 애널리틱스 가입을 확인하는 방법으로 인증을 하는데 저는 애널리틱스 인증 방법으로 통과했네요 위와 같이 Sitemaps 메뉴에서 아까 플러그인을 통해 생성한 sitemap.xml과 rss2.xml을 추가해 주세요! 보통 등록후 2~3일동안 데이터 수집 처리 과정이 걸린다고 합니다! 네이버네이버 웹마스터로 들어갑니다! 그 다음 연동 사이트 목록 페이지에서 내 사이트 추가에 블로그 주소를 추가해 줍니다. 이때 인증과정이 있는데 저는 두번쨰 방법으로 통과했어요. icarus 테마의 경우는 icarus\\layout\\common\\head.ejs에 123456789&lt;meta charset=&quot;utf-8&quot; /&gt;&lt;% if (get_config('meta_generator', true)) { %&gt;&lt;meta name=&quot;generator&quot; content=&quot;Hexo &lt;%= hexo_version() %&gt;&quot; /&gt;&lt;% } %&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1&quot; /&gt;&lt;meta name=&quot;naver-site-verification&quot; content=&quot;4f3c8ad54fee3ab0c7**********************&quot;/&gt;&lt;%- meta() %&gt;&lt;%- autoCanonical(config, page) %&gt;&lt;title&gt;&lt;%= page_title() %&gt;&lt;/title&gt; 이런식으로 meta가 모여있는곳에 넣어주면 됩니다! 그 다음 아래의 사진처럼 요청 탭에 가셔서 RSS와 사이트맵을 제출해줍니다! 다음다음은 다음 검색 등록에 들어가서 블로그 등록을 입력하시면간편하게 등록할 수 있습니다!! 저는 3일정도 걸렸습니다! 이것으로 블로그를 만들 수 있었는데요! username.github.io에는 hexo g를 통해서 생성된 public폴더 안의 내용만 올라가니프로젝트 전체를 담을 레포를 하나 더 파서 저장해두시는걸 추천합니다! 저는 이때 .gitignore를 사용해서 쓰고있습니다! 123456789.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/.idea/_multiconfig.yml 하다가 막히시는 부분이 있으면 댓글로 남겨주세요! Refenence https://alleyful.github.io https://www.holaxprogramming.com Thanks to 응원해주신 비아이즈 (Vision &amp; A.I. study, Be eyes) 여러분 감사합니다! 오타 잡아주신 Anna님 감사합니다! 오타와 깨진 텍스트 잡아주신 시한님 감사합니다!","link":"/2020/03/06/build-blog-with-hexo-github/"},{"title":"[Level 1] 프로그래머스 시저 암호 코틀린 풀이","text":"프로그래머스 시저 암호 코틀린 풀이 문제 소개이번에 풀어볼 문제는 카이사르 암호, 시저 암호로 불리는 암호에 관련된 문제이다. 문제풀이문자열 분기치기우선 이번에는 문자단위로 컨트롤해야하니 3가지의 경우로 각각 나누어서 when을 사용했습니다. 1234567s.map { when (it) { in 'A'..'Z' -&gt; it.caesar(n, 'A', 'Z') in 'a'..'z' -&gt; it.caesar(n, 'a', 'z') else -&gt; it }}.joinToString(\"\") 이렇게 짜면 문자열이 대문자인지, 소문자인지, 그 외인지를 판단해서 확장함수를 사용해서 넘겨서 시프트 처리를 하도록 했습니다. 확장함수의 구현12fun Char.caesar(c: Int, n: Char, m: Char): Char = (n.toInt() + (toInt() - n.toInt() + c) % (m - n + 1)).toChar() 구현은 카이사르 암호의 법칙만 알고있다면 구현은 간단합니다. C라면 A로 부터 2를 더하면 되는것을 이용해서 입력받은 Char애서 시작문자(n)를 빼고 얼만큼 밀지 구해두고 % 를 이용해서 Z 에서 4칸을 밀면 D로 넘어가도록 나머지 연산을 이용합니다! 두개를 합치면 끝이에요!! 정답 코드12345678910111213class Solution { fun solution(s: String, n: Int): String = s.map { when (it) { in 'A'..'Z' -&gt; it.caesar(n, 'A', 'Z') in 'a'..'z' -&gt; it.caesar(n, 'a', 'z') else -&gt; it } }.joinToString(\"\") fun Char.caesar(c: Int, n: Char, m: Char): Char = (n.toInt() + (toInt() - n.toInt() + c) % (m - n + 1)).toChar()} 시저암호! 흥미로운 문제였습니다! 출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges","link":"/2020/03/13/caesar-cipher/"},{"title":"[Level 1] 프로그래머스 자연수 뒤집어 배열로 만들기 코틀린 풀이","text":"[Level 1] 프로그래머스 자연수 뒤집어 배열로 만들기 코틀린 풀이 문제 소개이번에 풀어볼 문제는 자연수를 주면 뒤집고 배열로 만들면 되는 쉬운 문제입니다. 문제풀이방금전에 올린 포스트와 풀이는 비슷합니다. 다만 sum() 대신 뒤집고(.reversed()) .toIntArray()로 바꿔주면 됩니다. 정답 코드1234class Solution { fun solution(n: Long): IntArray = n.toString().map { it.toInt() - 48 }.reversed().toIntArray()} 전 문제와 거의 똑같네요 😅 출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges","link":"/2020/03/13/make-reverse-natural-number-array/"},{"title":"[Level 1] 프로그래머스 자릿수 더하기 코틀린 풀이","text":"[Level 1] 프로그래머스 자릿수 더하기 코틀린 풀이 문제 소개이번에 풀어볼 문제는 각 자릿수를 더하면 끝인 쉬운 문제입니다. 문제풀이간단합니다.String으로 바꿔준 후 map을 거쳐서 아스키코드를 이용해서 수로 바꿔주고 sum() 여기서 48을 빼준 이유는 48이 '0'.toInt()의 결과, 즉 0의 아스키코드이기 때문인데요. 1'N'.toInt() - '0'.toInt() 를 하면 문자 N에서 숫자N(0~9)이 나온다는 것을 이용했습니다. 정답 코드1234class Solution { fun solution(n: Int): Int = n.toString().map { it.toInt() - 48 }.sum()} 출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges","link":"/2020/03/13/add-digits/"},{"title":"[Level 1] 프로그래머스 문자열을 정수로 바꾸기 코틀린 풀이","text":"프로그래머스 문자열을 정수로 바꾸기 코틀린 풀이 문제 소개이번 문제는 문자열을 조건에 맞게 숫자로 바꾸면 되는 쉬운 문제이다! 문제풀이이번 문제의 경우의 수는 크게 3가지가 있는데 +숫자 숫자 -숫자 여기서 +만 제거해버리면 1, 2번을 하나로 묶어서 처리할 수 있습니다 if문을 써도 되지만 저는 엘비스 연산자 ?:를 이용하여 문제를 풀어봤습니다. 먼저 replace로 +를 제거한 뒤 toIntOrNull을 사용하여 3번의 경우에는 null을 반환하게 해줍니다. 이때 엘비스 연산자 ?:이 null일시에는 -를 제거하고 0에서 빼서 음수로 만들어줘서 처리합니다! 정답 코드12345class Solution { fun solution(s: String): Int = s.replace(\"+\", \"\").toIntOrNull() ?: 0 - s.substring(1).toInt()} 엘비스 연산자와 OrNull의 조합 정말로 유용합니다! 출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges","link":"/2020/03/13/string-to-int/"},{"title":"[Level 1] 프로그래머스 약수의 합 코틀린 풀이","text":"프로그래머스 약수의 합 코틀린 풀이 문제 소개이번에 풀어볼 문제는 약수의 합 구하기입니다!! 문제풀이가비지는 무시하고 풀면 매우 간단히 풀 수 있습니다. 약수의 최대치는 n / 2니까 1 ~ n/2의 range를 생성 range를 % 0으로 약수인지 체크하고 필터링 sum()으로 더하기 바로 코드로 씁니다! 정답 코드1234class Solution { fun solution(n: Int): Int = (1..n / 2).filter { n % it == 0 }.sum()} 너무 쉬워서 별다른 글이 필요없네요! 출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges","link":"/2020/03/13/sum-of-factors/"},{"title":"[Level 1] 프로그래머스 이상한 문자 만들기 코틀린 풀이","text":"[Level 1] 프로그래머스 이상한 문자 만들기 코틀린 풀이 문제 소개이번에 풀어볼 문제는 단어단위로 짝/홀에 따라서 대소문자를 적용하면 되는 문제입니다. 문제풀이우선 split을 이용하여 단어단위로 끊어준뒤 어짜피 다시 합쳐야하니joinToString { } transform 기능을 이용합시다. 123s.split(\" \").joinToString(\" \") { // 여기서 it으로 받아서 변형} 그리고 이제 글자단위로 바꿔주면 되는데 한번 더 쪼개야겠죠? 짝수 홀수를 구별하기 위해서 mapIndexed를 사용합니다. 받아서 짝수면 toUpperCase() 홀수면 c.toLowerCase() 처리를 하고다시 단어로 합쳐줍니다!! 123456it.mapIndexed { i, c -&gt; when (i % 2) { 0 -&gt; c.toUpperCase() else -&gt; c.toLowerCase() }}.joinToString(\"\") 합치면 끝! 정답 코드1234567891011class Solution { fun solution(s: String): String = s.split(\" \").joinToString(\" \") { it.mapIndexed { i, c -&gt; when (i % 2) { 0 -&gt; c.toUpperCase() else -&gt; c.toLowerCase() } }.joinToString(\"\") }} 2중 for문 쓴거같은 느낌이지만 실행시간 제약 없으니 넘어가죠… 출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges","link":"/2020/03/13/make-strange-string/"},{"title":"댓글기능 테스트","text":"테스트 페이지입니다. // title 밑에 댓글 기능을 추가했습니다!! 테스트용 페이지니 마음껏 달아주세요!!!!","link":"/2020/07/04/tmp-comment-test/"},{"title":"BOJ 9735 삼차 방정식 풀기 Kotlin 풀이","text":"[9375] 삼차 방정식, 코틀린으로 풀어보자 해당 포스트의 풀이를 그대로 제출하여 순위나 티어를 올리는 행위는 금지됩니다. 문제 소개이번에 풀어볼 문제는 9735번 삼차 방정식 풀기 입니다.썸네일과 다르게 현재는 플레1로 떨어졌다고합니다. 문제 접근 근의 공식처음 이 문제를 보자마자 삼차 방정식은 이미 근의 공식이 나와있으니 공식에 대입해서 문제를 풀면 되는줄 알고 공식에 대입해보려 했지만 해의 절대/상대 오차는 10^-4까지 허용한다 라는 말이 있는것으로 보아서 오차 문제는 아닌것같고… 제가 어딘가 놓친것 같습니다.식이 엄청나게 길거든요. 삼차 방정식 위키피디아 그래서 다른 방법을 시도해봤습니다. 이차 방정식으로 차수 낮추기 문제 조건문제를 다시 읽어보세요. 엄청난 조건이 숨어있습니다. 바로 입력으로 주어지는 방정식은 정수 해를 적어도 한 개 갖는다인데요 이 조건이 있기 때문에 항상 Ax^3 + Bx^2 + Cx + D = 0 식을(x + a)(bx^2 + cx + d) = 0 꼴로 인수분해가 가능하다는게 보장됩니다!! 그럼 고등학교 수준에서 문제를 해결할 수 있습니다. 문제 풀이 보장된 정수 해 찾기그럼 이제 보장된 정수 해가 하나있으니 이를 찾아봅시다. 저는 사실 유리근 정리 를 사용해서 문제를 해결하려고 시도했었습니다. 유리근 정리는 무엇일까요? 위 사진 출처 저 삼차 방정식에서 ±(D의약수) / (A의약수) 중에 정수 해가 하나 있다는 뜻이죠. 반복을 돌면서 1234567891011121314val (a, b, c, d) = readLine()!!.split(\" \").map { i -&gt; i.toInt() }when (d) { 0 -&gt; answer(listOf(a.toDouble(), b.toDouble(), c.toDouble()), 0.0) else -&gt; { var xList = a.divisor().map { ax -&gt; d.divisor().map { dx -&gt; dx.toDouble() / ax } }.flatten().distinct() xList += xList.map { x -&gt; -x } val x1 = xList.filter { x -&gt; a*x*x + b*x + c + d/x == 0.0 }[0] // x1이 정수 해 1번임 }} 정수 해 1개를 x1에 담아냅니다. 이 중 .map을 이용해서 ±(D의약수) / (A의약수)를 구하고 방정식에 넣어서 0이 되는지 확인하는 코드죠. 작동은 합니다만 문제가 있었습니다. 이 방식은 A와 D에 따라서 시간 소요가 너무 많이 됩니다.. 다른 방식을 찾아야합니다! 정수 해 메모리 초과 해결 A, B, C, D는 -2,000,000보다 크거나 같고, 2,000,000보다 작거나 같은 정수이고, A는 0이 아니다. 모든 해는 -1,000,000보다 크거나 같고, 1,000,000보다 작거나 같다. 주어지는 방정식의 해의 차이는 10^-4보다 크다. 이 말은 정수 해니까 저희가 아무리 반복을 많이 돌아도 (-2,000,000~2,000,000) 만 돌면 해결되니까 생각보다 많은 처리량은 아님을 알 수 있습니다. 그래서 직접 돌기로했습니다. 123456789101112when (d) { 0.0 -&gt; answer(listOf(a, b, c), 0.0) else -&gt; { for (x in -2000000..2000000) { if (a * x * x + b * x + c + d / x == 0.0) { answer(getQuadraticEquation(a, b, c, x.toDouble()), x.toDouble()) // 하나 구하면 break걸고 다른 함수로 계수를 넘겨줬어요 break } } }} 돌면서 직접 식에 넣어보고 0이 되는지 확인할껀데 혹시 모를 수 범위 초과를 피하기 위해서 양변을 x로 나눠서 진행했습니다. 그 다음 2차 방정식의 해를 구할 차례입니다! 이차방정식의 해를 구해보자우선 아까 한 정수해를 구한다면 Ax^3 + Bx^2 + Cx + D = 0식을\\[(x - x_1)(Ax_1^2 + (Ax_1 + B)x + (Ax_1 + B)x_1 + C)\\] 으로 변형 할 수있는데요. 이는 조립제법에서 얻어진 결과입니다. (인수분해도 똑같이 나와요) 위 사진 출처 이제 저희는 식을 이차 방정식으로 분해했고 답은 실수 해만을 출력하기 때문에 저희에게는 2가지 경우가 있습니다 판별식판별식이란 이차방정식의 계수들 간의 관계식으로, 그 근의 성질에 대한 정보를 알려 줍니다. 쉽게 말해서 판별식을 D(b^2 - 4ac)라고 할 때 판별식 D 근의 개수 D &gt; 0 서로 다른 두 실근 D == 0 서로 같은 두 실근(중근) D &lt; 0 서로 다른 두 허근 저희는 이미 정수해를 하나 가지고있고 D &lt; 0가 아닌 경우에는 근의 공식을 사용하고 중복을 제거하고 정수 해와 합치면 답이겠네요. 근의 공식! 12345678910111213141516fun formula(a: Double, b: Double, c: Double) = with(Math.sqrt(b * b - 4 * a * c)) { listOf((-b + this) / (2 * a), (-b - this) / (2 * a)) }fun answer(x: List&lt;Double&gt;, x1: Double) { val (a1, b1, c1) = x val dFormula = b1 * b1 - 4 * a1 * c1 println( when { dFormula &lt; 0 -&gt; listOf(x1) else -&gt; formula(a1, b1, c1) + x1 }.distinct().sorted().map { n -&gt; String.format(\"%.4f\", n + 0.0) }.distinct().joinToString(\" \") )} formula함수에서 판별식을 구하고, 중복을 제거하는 distinct()를 사용해서 D &lt; 0만 거르고 중복을 제거했어요! 정답 형식에 맞게 String.format(&quot;%.4f&quot;, n + 0.0)을 이용해서 소수점 4자리까지 표시하도록 셋팅했습니다. 이것으로 문제가 풀렸습니다. 정답 코드12345678910111213141516171819202122232425262728293031323334353637fun main(args: Array&lt;String&gt;) { repeat(readLine()!!.toInt()) { val (a, b, c, d) = readLine()!!.split(\" \").map { i -&gt; i.toDouble() } when (d) { 0.0 -&gt; answer(listOf(a, b, c), 0.0) else -&gt; { for (x in -2000000..2000000) { if (a * x * x + b * x + c + d / x == 0.0) { answer(getQuadraticEquation(a, b, c, x.toDouble()), x.toDouble()) break } } } } }}fun getQuadraticEquation(a: Double, b: Double, c: Double, x: Double) = listOf(a, a * x + b, (a * x + b) * x + c)fun formula(a: Double, b: Double, c: Double) = with(Math.sqrt(b * b - 4 * a * c)) { listOf((-b + this) / (2 * a), (-b - this) / (2 * a)) }fun answer(x: List&lt;Double&gt;, x1: Double) { val (a1, b1, c1) = x val dFormula = b1 * b1 - 4 * a1 * c1 println( when { dFormula &lt; 0 -&gt; listOf(x1) else -&gt; formula(a1, b1, c1) + x1 }.distinct().sorted().map { n -&gt; String.format(\"%.4f\", n + 0.0) }.distinct().joinToString(\" \") )} 결론지금 글 쓰는 시점에서 다른 분의 코드를 보니 Kotlin 제출자는 저를 제외하고는 한분 계시는데 엄청 깔끔하게 문제를 푸셨으니 한번 문제 풀이에 여러가지 방법으로 도전하시고 다른 분의 코드를 참고해보세요! 이 문제를 풀고 골드로 승급했습니다. 😂 문제 출처: 백준, https://www.acmicpc.net/problem/9735","link":"/2020/06/23/boj-9735-solutions-of-cubic-equation/"},{"title":"🐑블로그 개선후기, 🎉Solved.ac 골드 달성","text":"[잡담] 블로그 개선, 솔브드 골드 달성🎉 블로그 개선한동안 코로나 여파와 지필고사 준비 때문에 블로그쪽은 신경을 많이 못썼습니다. 블로그에 현재 Icarus테마를 사용하고있는데 문제가 생겼습니다. Icarus테마가 원래는 2.0버전으로 다른 헥소 테마와 마찬가지로 ejs로 구성이 되어있었는데요. 3.0 소식이 뜨더니 JSX와 Inferno.js기반으로 싹 다 레이아웃을 갈아엎었더군요. 헥소 릴리즈 노트 즉, 예전에 썼던 Hexo Blog 설치글이 먹히지 않는다는 소식이었습니다. 다행히 2.0버전을 아직도 배포는 하고있기에 임시 방편으로 2.0으로 사용하라고 적어두긴 했습니다만 찜찜해서 제가 3.0을 적용해보려고했습니다. Gatsby로?사실 웹 지식이 많이 없는지라 Icarus 3.0에 지금과 같은 블로그를 다시 만들 수 없을 줄 알고 요즘 유행같아보이는 Gatsby를 설치해서 Hexo 대신 사용해보려고 했습니다. 근데 Gatsby는 웹 프론트엔드에 관한 지식이 없으면 미리 만들어진걸 받아서 해야하는데 괜찮은 스타터 테마들은 Gatsby버전이 바뀌면서 호환 문제가 생기거나 5시간째 이미지를 프로세싱하는 무한 로딩 오류가 뜬다던지(…) 결국 이슈하나 던져두고 괜찮은 다른 테마 하나 건져서 설치까지는 해놨지만 역시 Hexo Icarus가 너무 강력하더군요 다시 Icarus 3.0으로그래서 시험도 끝났겠다 예전에 포기했던 3.0버전을 적용하려 다시 Icarus 테마 적용을 시도했습니다. 우선 제일 크게 바뀐점은 ejs -&gt; jsx로 이전에 포스팅했던 플러그인들이 먹지 않습니다… 저기에 소개한 플러그인은 제 예전 2.0 블로그에 전부 적용해뒀었는데요. hexo-autonofollow hexo-auto-canonical hexo-generator-seo-friendly-sitemap hexo-generator-feed hexo-related-popular-posts hexo-generator-robotstxt hexo-asset-link 이 중 hexo테마에 직접 코드를 추가해서 적용했던 hexo-related-popular-posts와 hexo-auto-canonical이 문제가 된겁니다. 관련 포스트 기능은 우선 사용을 해제한 상태고 auto-canonical같은 경우는 이미 hexo테마에서 어느정도 커버를 쳐주는것 같아서 빼기로했습니다. 사실 이 두개는 현재 icarus 3.0에와서 큰 문제는 없는 것 같더라고요.문제가 생기면 추후에 다시 알아봐야겠습니다. 그리고 화면 우측 아래에 띄워진 Live2d도 그대로 HTML코드에 심어주고 styl파일에 커스텀 info 임베딩도 추가했습니다. 이거요 이 작업을 끝내고 보니까 Icarus도 미안했는지 이번 업데이트에 사이버 펑크 테마를 추가해줬더라고요. 그래서 냅다 적용을 해봤습니다. 다행히 현재 낮/밤 모드를 icarus에서 fork해서 작업물을 공유해주시는 분이(아마 Icarus 제작자분중 한분) 발빠르게 낮/밤기능을 넣어주셔서 보기 싫으면 밤모드를 쓰면 되는 관계로 현재 제 블로그는 사이버펑크/밤으로 셋팅이 되어있습니다만 밤모드에 일부분 사이버 펑크 테마가 묻어있네요. 결국 현재 보시는것과 같은 블로그가 완성되었습니다!🎊🎉✨ Solved.ac사실 이번에 하고 싶었던 것 중 하나가 알고리즘 공부하기였습니다. 프로젝트 보다도 가볍게 시작할 수 있고 짧은 문제는 금방 풀리는 장점덕에 공부하면서 틈틈히 시도할 수 있고, 마침 집에 종만북 1, 2를 사두고 조금 읽은지라 마저 읽으면서 진행하려던 찰나, https://solved.ac/가 알파버전이 릴리즈되어서 당장 가입하고 백준과 연결했습니다. 솔브드는 백준과 연동하여 문제들에 태그와 난이도를 붙여주는데 특히 푼 문제에 기반하여 경험치를 주고 이를 게임처럼 랭킹으로 보여주는것이 인상깊었습니다. 저는 쉬운 브론즈 문제 그것도 5티어 문제를 50문제쯤 풀어두고 실버1문제, 골드1문제가 풀려있는 상태여서 처음에는 실버 5티어였습니다. 그러던 와중에 다이아 문제 하나를 우연히 SNS에서 보게되었는데 이게 고등학교 수학을 이용하면 저도 풀 수 있겠더라고요. 그래서 고인물님이 주신 힌트(고등 수학으로 가능하다)를 듣고 Kotlin으로 2일동안 삽질을 한 결과… 결국 이 문제를 풀었습니다. 나중에 풀이 글을 쓸 예정입니다. 티어별로 주는 경험치가 확 차이나다 보니까 다이아5문제를 푸니까 순식간에 골드로 승급했습니다!🎉🎉🎉🎉 앞으로도 틈틈히 ps를 열심히 공부해서 골드 3을 넘어서 플레까지 가고싶네요. 그럼 오늘도 늦었으니 자러가보겠습니다.👋(4시)","link":"/2020/06/22/solved-ac-gold-achieve/"},{"title":"깃헙 프로필 README로 5분만에 만들기","text":"Github Profile README로 5분만에 만들기! Github가 최근에 자신의 깃허브 페이지 메인에 README.md를 통해서 자신의 프로필을 깃허브에 띄울 수 있는 기능을 추가했습니다. README를 이용하면 기존의 몇가지 안되는 옵션보다 시각적으로 잘 드러나고 유연하게 꾸밀 수 있고,Markdown 또한 손쉽게 익힐 수 있어서 잘 이용한다면 개성넘치는 깃허브 메인을 만들어 볼 수도 있겠네요! 우리가 필요한건 없어도 좋지만 있으면 더욱 좋은 markdown 기초 지식 깃허브 계정 이 두가지면 충분합니다! 깃허브에 README 띄우기이 기능을 이용하시려면 우선 깃헙에서 해당 기능을 활성화 시켜야합니다. 우선 화면 우측 상단에 위치한 New repository를 눌러서 새로운 저장소를 만들어줄겁니다! 이때 일반 repository가 아니라 프로필 메인용 README repo로 인식되게 해야합니다. 위의 이미지에서 볼 수 있듯이 내 계정의 아이디 를 repo 이름으로 설정해주시면 됩니다. 올바르게 설정하셨다면 위 사진처럼 밑에 초록색 창이 뜨면서 You found a secret!이라고 반겨줍니다. 이떄 당연히 repo는 public으로 해두셔야하고 저는 편의상 Initialize this repository with a README 를 체크해서 바로 README를 생성하겠습니다! 이제 깃허브 메인에 방금 생성한 repo의 README.md가 깃허브 메인에 뜰겁니다!!🎉🎉 README꾸미기README.md는 깃허브 마크다운으로 이루어지기 때문에 저희는 이미지, GIF, 이모티콘, 텍스트등을 넣을 수 있고 깃헙 액션을 이용해서 동적으로 데이터를 가져와서 띄워주는등 무궁무진한 활용이 가능합니다. 우선 좋은 저장소를 하나 추천드리자면 Awesome-Profile-README-templates에서 다양한 재밌는 프로필 예제를 접할 수 있고 여기서 영감을 얻을 수 있습니다! 그리고 마크다운이 익숙하지 않으신 분은 https://guides.github.com/pdfs/markdown-cheatsheet-online.pdf 을 읽어보시면 기초적인 마크다운 지식을 습득하실 수 있습니다! 수정 방법간단합니다! 방금 생성한 자신의 깃허브 REPO에 들어가셔서 수정버튼을 눌러주시면 됩니다! 그리고 사진등 파일 업로드는 Add file을 통해서 깃허브에 올려주신 다음ReadMe에 추가하실 때 꼭 해당 파일의 절대경로를 이용해서 업로드해주세요! 예제 소개제 깃허브 프로필 같은 경우는 이런식으로 꾸며놓았는데요 이 중에서도 방문수(hits)와 제 깃헙 상태(?)와 밑의 버튼들을 설명해드리겠습니다!(gif는 해당 repo에 업로드하신 후 사진과 같은 방법으로 넣으시면 됩니다) hits(방문수) 먼저 hits입니다! https://hits.seeyoufarm.com/ 로 들어가신 다음 스크롤을 내리시면 창이 하나 뜹니다. 여기에 깃헙 아이디를 적고 copy를 누르고 붙여 넣으시면 끝입니다! 간단하죠? Github ReadMe Stats 이 기능은 anuraghazra 개발자의 github-readme-stats를 이용할겁니다! 들어가시면 다양한 예제가 있습니다. 저같은 경우는 1![Kinetic27's github stats](https://github-readme-stats.vercel.app/api?username=Kinetic27&amp;show_icons=true) 와 같이 이미지 마크다운으로 이렇게 넣어주었습니다. 저걸 복사하시고 []안의 이미지 소개 문구, ()안의 링크의 아이디만 본인의 것으로 교체해주시면 문제없이 작동합니다! Solved.ac 마찬가지로 Solved.ac의 티어를 예쁘게 표시해주고 형식은 마크다운입니다. 1[![solved.ac tier](http://mazassumnida.wtf/api/generate_badge?boj=kinetic27)](https://solved.ac/kinetic27) 여기서 kinetic27을 자신의 아이디로 수정하시면 되겠군요. @ccocosy님이 개발하셨습니다! 깃허브 버튼들저는 버튼을 생성할 때 shields.io를 사용했습니다! 사이트 제목 바로 아래 밑줄이 입력창입니다 원하시는 커뮤니티, 웹 사이트 등등을 입력하시면 이미 만들어진 예제들이 나옵니다! 예시로 youtube를 검색한 다음 아무거나 하나를 눌러보겠습니다. 요구하는 칸을 채워준후 markdown 복사 버튼을 누르니 1![YouTube Video Likes](https://img.shields.io/youtube/likes/abBdk8bSPKU?style=social) 와 같이 마크다운 텍스트가 복사됩니다. 이것도 ReadMe에 넣으시면 잘 작동할겁니다! 끝지금까지 ReadMe 프로필을 추가하고 활용하는 방법에대해서 알아봤는데요. 생각보다 시간은 오래 안걸리니 바로 적용해보셨으면 좋겠습니다! 제 github에 가시면 제가 어떻게 작성했는지 참고하실 수 있습니다제 ReadMe raw 파일","link":"/2020/07/14/git-profile/"},{"title":"샌즈와 함께 골 때리게 개발을 해보자 - 20chan&#x2F;SansTyping","text":"겁 나 어 렵 습 니 다 오늘의 레포오늘 소개해드릴 레포는 SansTyping입니다! C#으로 제작된 이 프로젝트는 토비 폭스가 제작한 롤플레잉 비디오 게임인 언더테일의 캐릭터 샌즈가 타이핑을 할 때마 샌즈 목소리로 말을 해주는 20chan님의 레포입니다! 재밌는 아이디어로 제작된 이 프로그램을 저는 혼자 개발할 때 powermode 플러그인과 함께 사용하고 있습니다 설치해보자먼저 깃허브의 릴리즈 탭으로 들어갑니다 그 다음 SansTyping_v1.1.zip(현 시점 최신버전) 압축파일을 받아줍니다. 파일 구조는 이러합니다 압축을 풀고 SansTyping.exe 파일을 실행합니다. 샌즈와 함께 골 때리는 개발을 즐겨보세요 :)","link":"/2020/09/17/sans-typing/"},{"title":"킹받는 BOJ 익스텐션 커스텀하기 + 적용법","text":"BOJ 출력메시지! 팩트폭력(?)하게 바꿔보자! 오늘의 레포오늘 소개해드릴 레포는 Hell-BOJ-Verdict-Message-with-kk입니다! 이 레포는 나정휘님이 만드신 Hell-BOJ-Verdict-Message 레포를 fork한 뒤에 kiwiyou님이 짜신 스크립트에서 아이디어를 얻어서 제가 이 두가지를 합쳐놓은 레포입니다. Hell-BOJ-Verdict-Message나정휘님이 만드신 크롬 브라우저 확장은 아래 사진과 같이 BOJ의 채점 결과를 바꾸어줍니다. Kiwiyou님의 ㅋ 스크립트그리고 Kiwiyou님이 짜신 ㅋ 스크립트는 아래와 같은데요 채점 결과 항목을 status-table라는 ID를 가진 표를 가져와서 for 반복문으로 접근하면서 정답이 아닌 경우에만 ㅋ을 달도록 하셨습니다. 저는 이 두가지를 합쳐보려고합니다. ㅋ 스크립트를 HBVM에 적용해보자나정휘님의 코드는 12345678910111213141516171819202122let arr = document.getElementsByClassName(\"result\");const RED = \"&lt;span class=\\\"result-wa \\\"&gt;\";const BLUE = \"&lt;span class=\\\"result-ce \\\"&gt;\";const GREEN = \"&lt;span class=\\\"result-ac \\\"&gt;\";const END = \"&lt;/span&gt;\";const conv = { \"맞았습니다!!\": \"맞았다!!\", \"틀렸습니다\": `데이터${END}${BLUE}는 ${END}${GREEN}맞았습니다.${END}${BLUE} 니는 ${END}${RED}틀렸습니다.`, \"런타임 에러\": \"사용자 불량\", \"시간 초과\": `${END}${RED}시간은 금이다.`, \"컴파일 에러\": `컴파일러${END}${BLUE}는 ${END}${GREEN}맞았습니다.${END}${BLUE} 니는 ${END}${RED}틀렸습니다.`, \"메모리 초과\": `${END}${RED}다다익램`, \"출력 초과\": \"꼬리가 길면 잡힌다.\"};for(let i in arr){ let now = arr[i].innerHTML; let str = arr[i].innerText; if(conv[str] == undefined) continue; now = now.replace(str, conv[str]); arr[i].innerHTML = now;} 이렇게 짜여져있었습니다 마찬가지로 반복을 돌고있네요. 제가 추가한 부분은 간단합니다, Kiwiyou님의 코드처럼 1let stat = document.getElementById('status-table'); 를 통해서 Element를 불러온 후 인덱스를 통해서 채점 아이디에 접근했습니다. 1id = stat.rows[i].cells[0].textContent; 그 다음 채점 아이디를 비교하면서 정답이 아니고 중복이 아닌 채점 결과에 ㅋ을 붙여줍니다 1234if(str !== \"맞았습니다!!\" &amp;&amp; tmp !== id) now += 'ㅋ'.repeat(t++);else t = 1; kiwiyou님처럼 이때 후위 연산자를 이용하여 다음번에 repeat할때는 ㅋ이 한개씩 더 추가되도록 하였습니다. 전체코드이렇게 짜여진 전체 코드는 이러합니다. 123456789101112131415161718192021222324252627282930313233343536373839let arr = document.getElementsByClassName(\"result\");let stat = document.getElementById('status-table');const RED = \"&lt;span class=\\\"result-wa \\\"&gt;\";const BLUE = \"&lt;span class=\\\"result-ce \\\"&gt;\";const GREEN = \"&lt;span class=\\\"result-ac \\\"&gt;\";const END = \"&lt;/span&gt;\";const conv = { \"맞았습니다!!\": \"맞았다!!\", \"틀렸습니다\": `데이터${END}${BLUE}는 ${END}${GREEN}맞았습니다.${END}${BLUE} 니는 ${END}${RED}틀렸습니다.`, \"런타임 에러\": \"사용자 불량\", \"시간 초과\": `${END}${RED}시간은 금이다.`, \"컴파일 에러\": `컴파일러${END}${BLUE}는 ${END}${GREEN}맞았습니다.${END}${BLUE} 니는 ${END}${RED}틀렸습니다.`, \"메모리 초과\": `${END}${RED}다다익램`, \"출력 초과\": \"꼬리가 길면 잡힌다.\"};let t = 1, tmp = \"\", id;for(let i in arr){ let now = arr[i].innerHTML; let str = arr[i].innerText; if(conv[str] == undefined) continue; id = stat.rows[i].cells[0].textContent; if(str !== \"맞았습니다!!\" &amp;&amp; tmp !== id) now += 'ㅋ'.repeat(t++); else t = 1; now = now.replace(str, conv[str]); tmp = id; arr[i].innerHTML = now;} 직접 적용해보자이 크롬 익스텐션을 이제 적용해봅시다! 먼저 제가 올린 Hell-BOJ-Verdict-Message-with-kk 레포 릴리즈에 들어가서 Hell-BOJ-Verdict-Message-with-KK.zip를 다운로드하고 적절한 위치에 압축을 풀어주세요! 그 다음 크롬을 켠 후 주소창에 chrome://extensions/를 입력, 혹은 설정 - 확장프로그램의 경로를 통해서 확장프로그램설정에 접속합니다! 이제 우측 위의 개발자 모드를 켜시면 압축해제된 확장 프로그램을 로드합니다. 라는 버튼이 활성화됩니다! 이제 아까 확장을 풀어놨던 폴더를 찾아서 선택 버튼을 누르고 백준에 들어가면 잘 적용된 모습을 볼 수 있습니다! 제 채점현황을 봅시다! 엄청난 팩폭으로 PS력을 향상시켜주네요! 혹시 ㅋ을 빼고싶다면 원본인 나정휘님의 레포 Hell-BOJ-Verdict-Message를 받아서 적용을 하거나 바뀌는 멘트를 수정하고싶다면 스크립트 상단의 123456789const conv = { \"맞았습니다!!\": \"맞았다!!\", \"틀렸습니다\": `데이터${END}${BLUE}는 ${END}${GREEN}맞았습니다.${END}${BLUE} 니는 ${END}${RED}틀렸습니다.`, \"런타임 에러\": \"사용자 불량\", \"시간 초과\": `${END}${RED}시간은 금이다.`, \"컴파일 에러\": `컴파일러${END}${BLUE}는 ${END}${GREEN}맞았습니다.${END}${BLUE} 니는 ${END}${RED}틀렸습니다.`, \"메모리 초과\": `${END}${RED}다다익램`, \"출력 초과\": \"꼬리가 길면 잡힌다.\"}; 부분을 잘 수정하면 되겠네요! 재미있게 읽으셨거나 오류가 발생하신다면 댓글을 달아주시면 감사하겠습니다!! 도네이션 페이지 추가새로 글을 쓰기는 애매해서 이 글 하단에 알려드립니다! 블로그에 가끔 후원을 보내주시는 분들이 생겨서 도네이션 감사 페이지를 제작했습니다! 후원을 보내주실때 메시지를 같이 보내주실 수 있는데 해당 메시지와 함께 저 페이지에 올려드리고 받은 후원금은 주로 밤샘 작업을 위한 커피로 사용됩니다ㅠㅠ 혹시 이름, 메시지를 바꾸고싶으신분은 연락처로 말해주시거나 댓글을 달아주세요!","link":"/2020/09/16/hell-boj-verdict-message/"},{"title":"&#39;I want go home&#39; 레포에서 오픈소스 기여 연습하기","text":"오픈소스 기여를 언젠가는 해보고싶었다…쉽게 연습해보자 앞으로 종종 재밌거나 유용한 깃허브 repo들을 소개해드릴까 합니다! I want to go home트위터에서 이수호 개발자님의 트윗을 보게 되었습니다. I want go home 프로젝트 아직 팀에서 공동작업을 했지만 제가 뭔가 주도적으로 다른 프로젝트에 기여해보고 한적은 없었기 때문에 재밌어보였습니다. 집에 가고 싶을 때 각종 언어(프로그래밍 언어, 인간 언어, 동물 언어 모든 걸 포함)로 집에 가고 싶음을 어필하는 저장소입니다. 제가 fork 했을 당시에는 아직 한글 프로그래밍 언어 아희로 쓰여진 글이 없었기에 아희로 코드를 짜고 PR을 넣었습니다. 기존 레포를 fork하고 나면 fork한 레포 상단에 풀리퀘를 넣을거냐고 깃허브가 친절히 표시를 해주더군요 이후에는 각자 자신이 좋아하는 언어들로 코드를 짠 후 커밋을 하면 됩니다. 제가 겪었던 시행착오들을 적어보겠습니다. PR시도 1차 넣었지만 #20에 이미 아희로 커밋을 하신분이 계셨습니다. 제가 fork하고나고 난 뒤 PR을 날리는 동안 먼저 PR하신분이 있던것이었습니다. 미쳐 확인을 못했네요. .aheui로 확장자를 저는 제출했었고 #20을 .aheui로 바꾸는 편으로 PR을 수정해달라는 피드백을 받았습니다 PR시도 2차 이번엔 기존 아희(aheui)가 ahui로 작성되어있고 txt로 코드를 적어놓은것을 언급하며 다시 PR을 시도했습니다 이때까지는 모르고있었습니다….우측 위에 +0 −13이 보이시나요추가된건 없고 제거만 했다는 이야기입니다… 실수로 작업했던 아희 코드를 파일에 저장시키지 않고 커밋하고 푸시를 했던 것 같습니다… 착각하고 풀리퀘를 날렸지만 통과가 되어서 아희 레포에 아희로 쓰여진 집에 가고싶다가 없는 상태였습니다. 다행히 이전에 아희 코드를 작성하셨던분이 이 문제를 발견해주셔서 Revert 되었습니다. PR시도 3차 다시 fix한 후 PR을 날렸고 이번에는 리뷰까지 확실히 마친 후 머지되었습니다🎉🎉 이렇게해서 아희로 저장소에 기여를 하게 되었습니다 소감PR을 해보면서 뭔가 재밌기도하고 뿌듯하기도해서 좋았던것 같습니다. 이번에 여러가지 실수들을 했지만 다음에 실제 프로젝트에 기여를 할 때는 조금 더 성공적으로 PR할 수 있는 밑거름이 된 것 같습니다. 특히 이번에 실수했던 fork를 했지만 원 저장소가 수정되어서 문제가 발생하는 경우가 있을 수 있기 때문에 이를 조심해야겠습니다. 또한 꼭 커밋하기 전에 Ctrl + S 를 누르고 저장을 한 후 커밋을 해야하고 풀 리퀘시 다시 코드 리뷰를 통해서 올바르게 올라갔는지 2차 확인을 거쳐야겠다고 생각했습니다. 이 I want go home 프로젝트에서는 프로그래밍 언어 뿐만이 아니라 인공어, 동물어 등등 다양한 방법으로 집가고싶다를 표현하며 PR을 연습할 수 있으니 한번 도전해보시는것도 좋을 것 같습니다! 다뉴님께서 이 프로젝트에 많은 기여를 하셨습니다. 어떻게 시작해야할지 모르겠다면 다뉴님이 PR을 엄청 잘 하고계시니 다뉴님의 PR을 참고하셔서 이슈를 남기셔도 좋을 것 같습니다. 집가고싶다…… 글에 사용을 허락해주신 다뉴님 감사합니다 🙌","link":"/2020/08/18/i-want-go-home/"},{"title":"2020년 회고와 새해 다짐","text":"2021년 되고난 후 써보는 2020년 돌아보기 2020년에 뭐 했더라 1. 입시2020년에는 드디어 입시가 끝났습니다! 입시가 막 끝나고 온라인 수업으로 학교도 전환했다보니 시간이 많아져서 못했던 활동들을 많이 할 수 있었습니다. 하루종일 집에만 박혀있으면서 힐링하느랴 건강도 많이 좋아진 것 같아요. 2. 웹 공부예전에 잠깐 기초만 해봤던 웹을 다시 배우고싶어서 Html5 + Css3 책을 구매해서 읽고있습니다. Do it 시리즈를 예전에 잘 읽었던 기억이 있어서 이 책을 구매해보게 되었습니다. 모질라 웹 배우기도 같이 읽고 있는데, 정리가 잘 된 문서라서 읽기 좋았습니다. 마침 제가 들어가는 학교가 웹을 가르치는 과목이 있다보니 미리 어느정도 배워두면 도움이 될 것 같습니다. 3. 게임 개발모자란 실력이지만 게임 개발팀에 합류하여 유니티를 이용하여 간단한 게임 제작에 참여하게 되었습니다. 유니티와 C# 자체를 거의 다뤄본적 없기 때문에 계속 찾아가면서 공부했습니다. 아직 완전히 공개를 안한 게임이라 나중에 출시가 끝나고나서 다시 기록을 남겨야 할 것 같습니다. 2021년 계획과 목표 1. 대학교 공부 열심히하기고등학교때는 솔직히 공부에 많이 소홀했습니다. 대학생활은 공부를 중점적으로 다뤄야 앞으로 뭐라도 할게 생기지 않을까… 그리고 장학금에 성적이 걸려있다보니 어느정도 성적도 나와야 부담을 조금 덜 것 같습니다. 2. 알고리즘 공부 본격적으로 시작하기적어도 기업 코테를 통과할 수 있을 정도의 실력을 만들고 싶습니다. 현재는 그냥 개발하면서 얻은 잡지식으로 쉬운 문제를 푸는 정도인데 실력을 키워서 여러 문제를 풀어보고 싶습니다. 3. 운동하기온라인 수업으로 학교가 전환되면서 분명 잠에 관한 문제는 해결되었지만 의자 - 침대 - 식탁 동선으로 생활하다보니 팔 근육량이 좀 없는 것 같습니다. 죽지 않으려면 어느정도 운동을 해야할 것 같습니다. 4. 면허 따기2종 면허를 따고싶어서 책을사서 필기를 공부하고 있습니다. 아마 1주일 안에 필기시험을 보러가고 장내 연습을 할 것 같은데 운전을 잘 할 수 있을지 모르겠습니다. 아마 이게 제일 먼저 이룰 목표가 되지 않을까 합니다. 모두 새해 복 많이 받으시고 커밋 열심히 하시길!!","link":"/2021/01/01/happy-new-2021/"},{"title":"&#39;christmas-tree&#39; 레포에 아희 묻히기","text":"다양한 언어로 크리스마스 트리를 만들어보자 christmas-tree카톡에서 Resten 개발자님이 보내주신 재밌는 레포를 보게 되었습니다. 이전에 작성했던 글에서 소개한 i-want-go-home과 같은 다양한 언어로 출력문, 코드를 작성하는 레포입니다. 레포 링크 Readme에 레포를 사용하는 방법이 잘 나와있습니다. 작성할 언어를 정해보자저는 우선 제가 좋아하는 언어인 아희를 사용하여 작성을 해보려고 했습니다.하지만 이미 빠르게 아희로 PR을 넣으신 분이 계셨습니다. 하지만 가이드라인에서 알 수 있듯이 그리고, 이미 작성된 언어가 있어도, 자신만의 트리를 추가하는거니,자신이 하고 싶은 언어명 으로 된 폴더에 다른 파일 명으로 자신의 크리스마스 트리를 추가할 수 있습니다. 이미 언어가 작성되어있어도 자신만의 트리 파일을 추가 할 수 있다고 합니다. 저는 그래서 아희 언어를 사용하여 PR을 넣어보려 했습니다. fork 고고우선 가이드라인대로 Fork를 한 뒤 새로운 branch를 하나 만들어줬습니다. 이제 코드를 작성한 후 해당 레포의 aheui 폴더에 아희 코드 파일을 추가한 후 PR을 넣으면 끝입니다. 아희 베이스 작성이번에 해볼 것은 아희 코드로 크리스마스 트리 아스키 아트를 출력하는 코드 만든 다음,진짜 트리 모양으로 코드를 변형해보려고 합니다. 먼저 검색을 통해서 크리스마스 트리 모양 아스키 아트 텍스트를 찾아봤습니다. 123456789101112131415161718 _ |\\ 0 /| |/|\\| | @ /+\\\u0005\u0005 +//o/\\\\o //+/@\\\\/+o /\\/o//+/\\\\\\\\ +///\\//\\o\\o+\\\\o o/+@/++/\\\\\\@\\\\/\\+ /\\/+///o/@\\o+/\\+\\\\o/+/\\/@//||\\/\\\\o\\\\\\o _ /__ /| || /__ /|| * | | (__)___ | * | ||___|/_ /__ /||___|/ /_/| | * | | |_|/ |___|/ 이제 아희로 해당 아스키 아트를 출력하는 코드를 먼저 작성할 차례인데…너무 깁니다. 아희 언어의 특성상 2~9의 숫자와 사칙연산 + 나머지연산으로 뽑아낸 값에 해당하는 코드포인트의 유니코드 문자를 UTF-8로 출력하기 때문에 긴 출력문을 만드려면 상당한 노력이 필요합니다. 하지만 이를 편하게하기 위해서 제가 만들어뒀던 툴이 있습니다. 플레이스토어에 배포해두었던 AheuiRo 앱 입니다. 저 아스키 텍스트를 AheuiRo앱에 돌려서 먼저 모양을 고려하지 않고 한 방향으로 작성된 아희 출력문을 얻어옵니다. 1반밙따밣밗따빠맣빠맣빠맣빠맣빠맣빠맣빠맣빠맣빠맣맣밢밟따밣다밦다맣박발따맣밣밭따빠맣빠맣빠맣빠맣빠맣빠맣맣밖밠따밪다밤따맣밢밡따밫다밠다맣밣밗따맣받밪타망밣밮따맣발밟따반다맣밮밠따밬다밭따맣박발따맣밣밮따빠맣빠맣빠맣빠맣빠맣빠맣빠맣맣밗밝따받다밨따맣밙밡따반다맣밤밝따밪다밭따맣밞밟따밤다밝다맣밮밝따받다밫따맣반밙따맣밣밥따빠맣빠맣빠맣빠맣빠맣빠맣빠맣빠맣빠맣맣밮밝따받다밭따맣박밙따맣밣밨따빠맣빠맣빠맣빠맣빠맣빠맣빠맣빠맣빠맣맣밣밣따맣반발따맣밣밭따빠맣빠맣빠맣빠맣빠맣빠맣빠맣빠맣맣밚밡따박다맣밚밣따밪다맣밡밢따밖다밠다맣반밚따맣밣밭따빠맣빠맣빠맣빠맣빠맣빠맣빠맣맣밪발따밠따밦다맣밙밞따박다맣밣밣따맣밞밞따밭다밝다빠맣맣박발따맣밣밮따빠맣빠맣빠맣빠맣빠맣맣밚밣따밪다맣밚밞따박다빠맣맣밪밚따밠따밦다맣밚밢따박다맣밟밡따밮다밝다빠맣맣밬발따밝따밦다맣반밚따맣밣밫따빠맣빠맣빠맣빠맣빠맣맣밚밞따박다빠맣맣발밣따밬다맣밚밡따반다맣밣밣따맣밟밟따밫다밝다빠맣맣발밟따박다맣발밣따받다맣받발따밝따밦다맣반밚따맣밣밫따빠맣빠맣빠맣빠맣맣밙밞따반다맣밟밞따밮다밠다맣밙밢따박다맣밪발따밝따밦다맣발밡따박다빠맣맣발밣따받다맣발밞따반다맣밞밡따밗다밝다빠맣빠맣빠맣맣반발따맣밣밮따빠맣빠맣빠맣맣밙밣따밬다맣밙밡따박다빠맣빠맣맣밞밟따밨다밝다맣밚밡따반다빠맣맣밟밟따밨다밝다맣밪밚따밠따밦다맣밢밞따밤다밠다맣밪밙따밝따밦다맣밚밣따밬다맣밞밢따밥다밝다빠맣맣밪밚따밝따밦다맣박밚따맣밣밭따빠맣빠맣맣받발따밠따밦다맣밚밞따박다맣밙밣따받다맣밣밣따맣밙밡따박다맣밙밣따밪다빠맣맣밙밢따반다맣밟밞따밗다밠다빠맣빠맣맣밣밣따맣밢밟따밨다밠다빠맣맣발밞따박다맣밡밟따밭다밝다맣발밣따밬다맣박발따맣밣밮따빠맣맣밙밞따박다맣밡밞따밮다밝다맣밙밡따반다맣밙밣따밬다맣발밢따박다빠맣빠맣맣받밙따밝따밦다맣발밟따박다맣밣밣따맣밢밞따밮다밝다맣받밙따밠따밦다맣밙밣따받다맣발밟따반다맣밟밟따밨다밝다맣밚밣따밪다맣밢밟따밨다밝다빠맣맣박밚따맣밣밫따맣밪밙따밠따밦다맣밚밞따반다맣발밣따밬다맣밚밟따박다맣밟밟따밗다밠다맣밚밟따반다맣밣밣따맣밚밢따반다빠맣맣밥밝따받다밭따빠맣맣밡밟따밫다밝다맣밙밟따반다맣밞밟따밭다밠다빠맣맣밬밙따밠따밦다맣밢밟따밥다밠다빠맣빠맣맣밪발따밝따밦다맣밣밤따맣밞밟따밣다밦다맣박밙따맣밣밭따빠맣맣발밡따반다맣밡밡따밣다밦다빠맣맣밣밗따맣밚밢따반다맣밗밝따밪다밖따맣밣밥따빠맣맣밭밝따밪다밖따빠맣맣밣밗따빠맣빠맣빠맣빠맣빠맣맣밙밟따반다맣밟밞따밣다밦다빠맣맣밣밗따맣밚밟따박다맣밥밝따밬다밮따맣박밙따맣밣밭따맣밖밠따받다밮따맣밣밭따맣밦밠따맣밣밗따맣밖밝따밪다밥따맣밣밥따맣밮밠따받다밗따맣밣밗따맣밣밚따맣밡밞따밣다밦다빠맣맣발밝따밦다맣밢밟따밣다밦다빠맣빠맣맣밣밨따맣밤밝따밪다밭따맣밣밫따맣밦밝따맣밣밥따맣밮밠따밬다밗따맣밣밮따맣밮밝따밪다밭따맣박밚따맣밣밫따맣밗밝따밬다밨따맣밞밟따밣다밦다빠맣빠맣맣밗밝따밪다밥따맣밙밢따박다맣밟밟따밣다밦다맣밣밨따빠맣빠맣맣발밞따박다맣밡밢따밣다밦다빠맣맣밣밫따맣밙밡따박다맣밫밠따밬다밨따빠맣맣밞밟따밣다밦다빠맣빠맣맣밨밝따밬다밤따맣밙밞따반다맣반발따맣밣밤따빠맣빠맣빠맣빠맣맣밚밢따박다맣밟밟따밣다밦다맣발밟따반다맣밫밝따밬다밨따맣밣밭따맣밖밠따밪다밭따맣밣밭따맣밦밠따맣밣밭따맣밥밝따밬다밗따맣밣밨따맣밭밝따밪다밖따맣박밙따맣밣밥따빠맣빠맣빠맣맣밖밝따밪다밥따맣밞밞따밣다밦다맣밗밠따밬다밫따맣밚밢따반다맣밣밤따빠맣맣밫밠따밪다밫따맣밢밞따밣다밦다빠맣빠맣맣밭밝따밪다밥따맣밚밟따반다맣마희 마지막에서 두번째의 마는 스택을 비우기위한 코드인데 필요없으니 버립시다.(아직 앱 업데이트를 못했습니다 ㅈㅅ…) 그 다음 크리스마스 트리 모양을 만들 차례인데 디자인 센스가 없어서 그냥 좀 길다란 삼각형 아래에 사각형을 달아보려고합니다. 먼저 메모장을 이용해서 엔터를 넣어주는 작업을 했습니다. 코드 변형 먼저 이런식으로 삼각형을 생각하면서 엔터를 넣어줍니다. 그 다음 띄어쓰기를 밑에부터 1개씩 늘려주며 넣으면 되는데엔터를 넣을때와 마찬가지로 너무 넙적해지지 않게 두줄씩 같은 개수의 띄어쓰기를 넣어주었습니다. 밑에 남겨둔 줄은 트리의 밑동인 사각형을 만들기 위한 줄 입니다. 이번엔 코드양이 좀 길고 변형을 많이 해야하니 Avis라는 툴을 사용해보겠습니다. 유명한 아희 인터프리터 3종중에 편의 기능을 제일 많이 지원하는 툴 입니다. 그 다음 코드 시작을 위해서 아를 첫칸에 삽입해줍니다. Avis에는 종성이 ㅏㅏㅏㅏㅏㅏ 로 된 코드를 ㅓㅓㅓㅓㅓㅓ 로 바꿔주는 식의 좌우반전, 다시 그리기 등의 기능이 있는데요. 이 기능을 활용하여 적당히 수정해준 후, 띄어쓰기를 모두 1 로 바꿔서 간격을 일정하게 만들어줍니다.그럼 완성됩니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061아 분 희 땨벉붏 뿌떠벇 뺘멓맣빠뭏 뿌멓뻐멓뻐 뺘멓맣빠맣빠뭏 붒더벓떠벏벒멓 먛더박발따맣밣밭뚜 뿌멓뻐멓뻐멓뻐멓뻐 뺘멓맣맣밖밠따밪다밤뚜 붃벓멓더벐더벛떠벑벒멓 먛떠받밪타망밣밮따맣발밟뚜 불벅멓떠벝더벜떠벐벞멓더번 먛떠밣밮따빠맣빠맣빠맣빠맣빠뭏 붍벉멓떠벘더벋떠벍벇멓멓뻐멓뻐 뱐떠다맣밤밝따밪다밭따맣밞밟따밤두 붑벓멓떠벉번멓떠벛더벋떠벍벞멓더벍 뺘떠맣빠맣빠맣빠맣빠맣빠맣빠맣빠맣빠뭏 뿌멓뻐떠벘벓멓떠벉벅멓떠벝더벋떠벍벞멓 뺘멓맣빠맣빠맣빠맣빠맣빠맣빠맣맣밣밣따맣분 뿌멓뻐멓뻐멓뻐멓뻐멓뻐멓뻐멓뻐떠벝벓멓떠벌 먛멓밚밡따박다맣밚밣따밪다맣밡밢따밖다밠다맣분 불벚멓멓뻐멓뻐멓뻐멓뻐멓뻐멓뻐멓뻐떠벝벓멓떠벊 뱘떠따밦다맣밙밞따박다맣밣밣따맣밞밞따밭다밝다빠뭏 뭏더벚떠벓벊멓멓뻐멓뻐멓뻐멓뻐멓뻐떠벞벓멓떠벌벅멓 뱖벊따박다빠맣맣밪밚따밠따밦다맣밚밢따박다맣밟밡따밮두 뿌멓뻐멓뻐멓뻐떠벛벓멓떠벊번멓더벖떠벍떠벌벜멓멓뻐더벍 뺘멓맣맣밚밞따박다빠맣맣발밣따밬다맣밚밡따반다맣밣밣따맣붋 뭏더벖떠벍떠벌벋멓더벋떠벓벌멓더벅떠벏벌멓멓뻐더벍더벛떠벏 뱒번따맣밣밫따빠맣빠맣빠맣빠맣맣밙밞따반다맣밟밞따밮다밠다맣붅 분떠벎벌멓더벋떠벓벌멓멓뻐더벅떠벑벌멓더벖떠벍떠벌벚멓더벅떠벒 먛더밞밡따밗다밝다빠맣빠맣빠맣맣반발따맣밣밮따빠맣빠맣빠맣맣밙밣뚜 붔떠벏벏멓멓뻐더번떠벑벊멓더벍더벘떠벏벎멓멓뻐멓뻐더벅떠벑벉멓더벜 뱕더다맣밪밚따밠따밦다맣밢밞따밤다밠다맣밪밙따밝따밦다맣밚밣따밬다맣붊 붒떠벐떠벌벋멓멓뻐멓뻐떠벝벓멓떠벊벅멓더벖떠벍떠벊벚멓멓뻐더벍더법떠벒 먛더밚밞따박다맣밙밣따받다맣밣밣따맣밙밡따박다맣밙밣따밪다빠맣맣밙밢따반두 붙떠벏벑멓더벅떠벎벌멓멓뻐더벐더벘떠벏벒멓떠벓벓멓멓뻐멓뻐더벐더벇떠벎벏멓 뱕더다맣발밣따밬다맣박발따맣밣밮따빠맣맣밙밞따박다맣밡밞따밮다밝다맣밙밡따반두 붚떠벎벒멓떠벓벓멓더벅떠벏벌멓더벖떠벍떠벉벋멓멓뻐멓뻐더벅떠벒벌멓더벜떠벓벉멓 뱕더다맣받밙따밠따밦다맣밙밣따받다맣발밟따반다맣밟밟따밨다밝다맣밚밣따밪다맣밢밟뚜 뭏더벅떠벏벊멓더벜떠벓벌멓더번떠벎벊멓더벖떠벐떠벉벚멓떠벛벓멓떠벊벅멓멓뻐더벍더벘 뱗벏따밗다밠다맣밚밟따반다맣밣밣따맣밚밢따반다빠맣맣밥밝따받다밭따빠맣맣밡밟따밫다밝두 붒떠벍떠벌벚멓멓뻐멓뻐더벐더법떠벏벒멓더벖떠벐떠벉벜멓멓뻐더벐더벝떠벏벎멓더번떠벏벉멓 먛더밣밤따맣밞밟따밣다밦다맣박밙따맣밣밭따빠맣맣발밡따반다맣밡밡따밣다밦다빠맣맣밣밗따맣붆 붋벉멓멓뻐멓뻐멓뻐멓뻐멓뻐떠벇벓멓멓뻐떠벆더벚떠벍벝멓멓뻐떠법벓멓떠벆더벚떠벍벇멓더번떠벒 뱐떠다맣밟밞따밣다밦다빠맣맣밣밗따맣밚밟따박다맣밥밝따밬다밮따맣박밙따맣밣밭따맣밖밠따받다밮뚜 붒더벓떠벎벑멓떠벊벓멓떠벇벓멓떠벇더벋떠벐벞멓떠법벓멓떠법더벚떠벍벆멓떠벇벓멓떠벐벖멓떠벝벓멓 뺘더맣맣발밝따밦다맣밢밟따밣다밦다빠맣빠맣맣밣밨따맣밤밝따밪다밭따맣밣밫따맣밦밝따맣밣밥따맣밮밠뚜 붖떠벍벇멓멓뻐멓뻐더벖더벓떠벏벎멓떠벘더벜떠벍벇멓떠벛벓멓떠벊벅멓떠벝더벚떠벍벞멓떠벞벓멓떠벇더벜 뱝더따맣밙밢따박다맣밟밟따밣다밦다맣밣밨따빠맣빠맣맣발밞따박다맣밡밢따밣다밦다빠맣맣밣밫따맣밙밡따박두 뿌멓뻐멓뻐멓뻐떠범벓멓떠벌번멓더번떠벎벉멓떠범더벜떠벍벘멓멓뻐멓뻐더벖더벓떠벏벎멓멓뻐떠벘더벜떠벐벛멓먛멓밚밢따박다맣밟밟따밣다밦다맣발밟따뱐뚜댜볕먛볋뱣몋뱕뗘땨볈뱤볎댜몋뱠뗘땨볕먛볋뱛몋뱥뗘땨볕먛뎌뱎볒밠뗘 맣밥밝따밬다밗따맣밣밨따뭏 붏멓떠벉벅멓떠벆더벚떠벍벝 밥따빠맣빠맣빠맣맣밖밝따붖 붃멓더벖더벓떠벎벎멓떠법더 밠따밬다밫따맣밚밢따반다뭏 뚜벛더벚떠벐벛멓멓뻐떠범벓 맣밢밞따밣다밦다빠맣빠맣뭏 두번떠벏벊멓떠법더벚떠벍벝 맣희키네틱제작크리스마스🎄 ㄹ자로 휘어지게 작성해보았습니다. 소감저번 PR보다는 나아졌으나…. 이번엔 코드를 한글자 잘못 작성한걸 발견하여 뒤늦게 재PR을 넣었습니다. 복잡한 코드 변형은 Avis가 더 좋은것 같고, 실행 경로 확인은 AheuiChem가 더 유리한 것 같습니다. 다들 크리스마스 전에 자기가 좋아하는 언어로 PR을 해보면 좋을 것 같습니다! 틈틈히 쉬운 아희 강좌글 작성을 하고 있습니다 크리스마스 전에 완성되면 좋겠네요 글에 사용을 허락해주신 Resten님 감사합니다 🙌","link":"/2020/12/12/christmas-tree/"},{"title":"[Level 2] 프로그래머스 삼각달팽이 코틀린 풀이","text":"[Level 2] 프로그래머스 삼각달팽이 코틀린 풀이 문제 소개이번에 풀어볼 문제는 삼각달팽이입니다. 위 사진처럼 반시계방향으로 회전하면서 숫자를 배열하는데 이를 가로로 썰어서 배열로 리턴해주면 되는 문제입니다. 문제풀이접근먼저 모눈종이와 같은 2차원 배열 공간을 떠올리고 사진을 변형해보았습니다. 그러면 좌표평면에 얹었다고 생각하고 이동 로직을 짤 수 있습니다. 위 사진에서 알 수 있듯이 아래 방향, 우측 방향, 좌상단 방향 3개를 반복하는데 개수가 n ~ 1까지 내려갑니다. 아래 방향 -&gt; y좌표 증가우측 방향 -&gt; x좌표 증가좌상단 방향 -&gt; x, y 둘다 감소 그렇다면 이 3가지만 신경을 쓰면 처리할 수 있습니다. 구현먼저 입력받은 n만큼 2차원 배열을 만듭시다 1val arr = Array&lt;IntArray&gt;(n) { IntArray(n) } 코틀린의 이차원배열은 배열 안에 배열을 넣어서 만들 수 있습니다. 그 다음 변수 x에는 0을, y에는 -1을 넣어줬습니다.-1을 넣은 이유는 처음에 무조건 아래로 움직이면서 시작하기 때문입니다. 그럼 아까 알아냈듯이 개수가 n ~ 1까지 내려가니 반복을 돕시다. 1234(1..n).forEach { i -&gt; repeat(n - i + 1) { j -&gt; }} 바깥쪽 루프는 n개의 직선으로 루프를 돌기 때문이고안쪽 루프는 각 직선이 요소를 n ~ 1개 갖기 때문입니다. 현재 적어야할 숫자를 알기위해서 식을 만들었습니다 1val l = (n - i + 2..n).sum() + j + 1 이제 3가지를 반복하니 3으로 나눈 나머지를 이용하면 됩니다. 12345678when (i % 3) { 1 -&gt; y++ // 아래로 2 -&gt; x++ // 우측으로 else -&gt; { // 좌상단으로 y-- x-- }} 그 다음 arr[y][x] = l으로 해당하는 위치에 값을 넣어줍시다. 1arr.flatMap { it.filter { value -&gt; value != 0 } }.toIntArray() 마지막으로 초기화시의 0을 없애고 하나의 배열로 합쳐주면 정답입니다! 정답 코드12345678910111213141516171819202122232425class Solution { fun solution(n: Int): IntArray { val arr = Array&lt;IntArray&gt;(n) { IntArray(n) } var (x, y) = arrayOf(0, -1) (1..n).forEach { i -&gt; repeat(n - i + 1) { j -&gt; val l = (n - i + 2..n).sum() + j + 1 when (i % 3) { 1 -&gt; y++ 2 -&gt; x++ else -&gt; { y-- x-- } } arr[y][x] = l } } return arr.flatMap { it.filter { value -&gt; value != 0 } }.toIntArray() }} 몇일 고민하던 문제가 풀려서 좋네요 :) 출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges","link":"/2021/02/15/a-triangular-snail/"},{"title":"별거 없는 2021년 회고","text":"별건 없지만 한걸 정리해보자 2021년 리뷰1. 학교 수업원하던 대학교에 입학하여 1학년을 무사히 끝마쳤습니다. 코로나 관련 정책이 바뀔 때 마다 학교의 지침도 계속 바뀌어서 조금 혼란스러웠지만 생각보다 IT과의 특성상 대면/비대면의 차이가 적어서 나쁘지 않았던 것 같습니다. 성적도 4점대를 받았고 2학기에는 21학점 듣기도 성공을하여 기분이 좋았습니다. 나름 좋은 친구도 조금 만들었고 나름 성공적으로 1년을 보낸 것 같은 기분이 들었습니다. 2. 조교 활동우연히 교수님과 대화를 하다가 학교 영재 교육원에서 일해볼 수 있는 좋은 기회를 얻었습니다. 4달정도 교수님을 도와서 학생들에게 앱 인벤터를 가르치는 활동을 하였습니다. 내가 알고있는 것과 그걸 남에게 가르치는것에 관련된 생각을 많이 하게 되었던 활동이었습니다. 가르치는 대상이 초등, 중학생이었는데 교수님이 설명하시던 내용을 잘 이해하도록 질문을 받고 설명하고 처리하는 과정이 즐거워서 생각보다 적성에 맞는구나 하는 생각이 들었습니다. 3. 면허 취득작년 목표를 달성하였습니다. 필기는 바로 합격하였고 장내, 도로 모두 실수로 인해 2트만에 성공하였습니다 ㅠㅠ 운전 관련 사고 사례를 보다보니 제 집중력으로 운전을 해도 되나라는 생각이 들기도하고 보험료와 관련된 이슈도 있다보니 아직 운전대를 잡고싶지는 않습니다. 그래도 면허를 취득했다는 것에 의의를 두고 만족합니다! 4. 동아리 활동Applay 동아리에 참가하여 활동을 시작했습니다. 처음 가입 당시에는 앱 관련 동아리로 알고 들어갔으나 종합 코딩 동아리(?) 였습니다. 가장 기억에 남는 활동은 해커톤 활동입니다. 해커톤을 자주 참여했어서 굉장히 기대를 하였지만 이번에는 비대면으로 진행하는지라 먹는 재미는 빠졌습니다… 저희 팀은 PTLI(개발 언어 테스트)라는 안드로이드 앱을 만들기로하고 제가 앱 개발 전반을 맡고 다른 분들에게 리소스와 아트 제작을 맡겨서 빠르게 완성을 하고 운좋게 동아리 해커톤 1위를 달성했습니다. 이후 이 프로젝트로 동아리 연합 발표회에서 발표도 했고 플레이스토어에 업로드도 해보아서 뿌듯했습니다. 이후 이러한 활동 완성도에 기여를 하고싶어서 동아리 임원에 가입하였습니다. 하지만.. 비대면으로 인해서 생각보다 계획중이던 활동들이 많이 취소되었고 생각보다 하반기 활동이 없어서 아쉬웠습니다. 5. 운동이번년도 목표인 운동을 이루기 위해서 운동을 시작하였습니다. 학교 수업으로 건강과 질병 수업을 들으면서 달리기 운동을 시작하였고 평일 일주일 3번을 목표로 집 앞 달리기를 먼저 시행하면서 기초 심폐지구력을 많이 길렀던 것 같습니다. 이후에 조금 더 엑티브한 운동을 하고싶어서 동생이 추천해준 복싱을 다니게되었습니다. 글을 쓰는 시점에서 약 11주차정도를 수강하고있고 가끔 스파링도 뛰기 시작하였습니다. 확실히 체력과 근력 두가지를 모두 챙길 수 있었습니다. 주말을 제외하고 매일 약 한시간 반 정도를 쓰고있는데 너무 괜찮은 운동인 것 같습니다. 6. 학부 연구생관심있던 패턴인식 연구실에 학부연구생으로 들어가게 되었습니다. 아직 1학년이었기 때문에 우선 딥러닝 스터디와 곧 프로젝트를 시작하게 될 예정입니다. 생각보다 연구실 분위기도 괜찮고 교수님께서도 학생들을 잘 케어해주시는 느낌이 들어서 잘 지내고 있습니다. 열심히 활동해봐야겠습니다. 7. 신년 목표컴활 1급 자격증 스터디와 알고리즘 스터디를 친구와 진행하고 있습니다.이제 막 3주차를 진행하고있는데 끝까지 잘 마무리되었으면 좋겠습니다. 그리고 역시 학점 4점 이상 마무리와 건강하게 한 해를 마무리하였으면 좋겠습니다. 모두 새해 복 많이 받으시고 공부 열심히 하시길!!","link":"/2022/01/01/happy-new-2022/"},{"title":"[Level 1, 카카오 인턴] 프로그래머스 키패드 누르기 코틀린 풀이","text":"[Level 1] 프로그래머스 [카카오 인턴] 키패드 누르기 코틀린 풀이 문제 소개이번에 풀어볼 문제는 [카카오 인턴] 키패드 누르기입니다. 키패드를 두손으로 누를때 좌우 어떤 손으로 눌러야 효율적일지 설명에 따라서 코드를 짜면 됩니다. 문제풀이 왼쪽 열의 3개의 숫자 1, 4, 7을 입력할 때는 왼손 엄지손가락을 사용합니다.오른쪽 열의 3개의 숫자 3, 6, 9를 입력할 때는 오른손 엄지손가락을 사용합니다. 이것은 단순히 if-else를 이용하여 처리하면 되는 간단한 문제지만 가운데 열의 4개의 숫자 2, 5, 8, 0을 입력할 때는 두 엄지손가락의 현재 키패드의 위치에서 더 가까운 엄지손가락을 사용합니다. 만약 두 엄지손가락의 거리가 같다면, 오른손잡이는 오른손 엄지손가락, 왼손잡이는 왼손 엄지손가락을 사용합니다. 부분이 문제의 핵심이었습니다.제가 생각한 구현 방법은 이러합니다. 거리를 통한 접근 먼저 키패드의 숫자들을 좌표 평면상으로 올려버립니다. 그럼 *은 (1, 1)로 3은 (3, 4)가 되는데 이렇게 좌표평면에 올려버리면 거리를 구할 수 있습니다. 예로 4(1, 3)와 9(3, 2)의 거리는 \\[\\sqrt{(X1 - X2)^2 + (Y1 - Y2)^2}\\] 거리를 구하는 식에 대입하여 \\[\\sqrt{(1 - 3)^2 + (1 - 4)^2} = \\sqrt{13}\\] 로 구할 수 있습니다. 이를 이용하여 왼손 - 목표 키, 오른손 - 목표키를 구하는것이 제 목표인데, 엄지손가락은 상하좌우 4가지 방향으로만 이동할 수 있으며 키패드 이동 한 칸은 거리로 1에 해당합니다. 라는 조건이있으니 단순히 유클리드 거리로 구할 수는 없습니다.하지만 이 거리의 경우의 수는 생각보다 적습니다. 거리가 가로(0 ~ 2), 세로(0 ~ 3)이기 때문에 이 수들의 제곱의 합을 조합해보면 됩니다. \\[0, 1, \\sqrt{2}, 2, \\sqrt{5}, 2\\sqrt{2}, 3, 10, \\sqrt{13}\\] 그래서 저는 우선 이 거리들을 상하좌우로 움직였을 때의 거리로 반환해주는 함수를 하나 작성했습니다. 1234567891011fun Int.toKeypadDistance(): Int = when (this) { 0 -&gt; 0 1 -&gt; 1 2 -&gt; 2 4 -&gt; 2 5 -&gt; 3 8 -&gt; 4 9 -&gt; 3 10 -&gt; 4 else -&gt; 5} 그 다음 우선 이 함수를 이용하려면 키패드의 문자를 좌표로 반환하는 함수가 필요합니다. 1234567891011121314fun String.getLoc(): Pair&lt;Int, Int&gt; { /* ^ * 4 | 1 2 3 * 3 | 4 5 6 * 2 | 7 8 9 * 1 | * 0 # * ㅡ|ㅡㅡㅡㅡㅡ&gt; * | 1 2 3 */ val keyNum = \"*0#789456123\".indexOf(this) + 3 return Pair(keyNum % 3 + 1, keyNum / 3)} 그래서 *0#789456123에서 입력받은 문자의 순번을 찾아 3으로 나눈 나머지로 x를, 3으로 나눈 몫을 y로 반환하는 함수를 작성했습니다. 이제\\[\\sqrt{(X1 - X2)^2 + (Y1 - Y2)^2}\\]식을 코드로 작성해줍시다 12fun getDistance(one: Pair&lt;Int, Int&gt;, two: Pair&lt;Int, Int&gt;): Int = ((one.first - two.first + 0.0).pow(2.0) + (one.second - two.second + 0.0).pow(2.0)).toInt() 복잡해보이지만 Pair&lt;Int, Int&gt; 두개를 받아서 제곱하는게 전부입니다.저는 비교가 목적이니 루트는 생략하였습니다. 이제 필요한 함수들은 모두 작성이 끝났으니 메인 루프를 작성합니다. 눌러야할 숫자들이 담긴 배열을 가지고 for을 돌아줍니다. 돌면서 아까 만든 함수로 거리를 구해줍니다 123val leftDX = getDistance(left.getLoc(), it.toString().getLoc()).toKeypadDistance()val rightDX = getDistance(right.getLoc(), it.toString().getLoc()).toKeypadDistance() 이제 답은 왼손과 오른손으로 구분됩니다. 입력이 2580369에 속해있으면 좌측, 2580(중앙)인데 양손 거리가 같으면 왼손잡이일때 좌측 이 두가지를 제외하고는 전부 우측으로 보내면 됩니다. 조건문을 몰아넣어 조금 길어져서 변수로 빼내었습니다. 1234567891011answer += when { isInLeftSide || (isInMiddleSide &amp;&amp; isLeftCloser) -&gt; { left = it.toString() \"L\" } else -&gt; { right = it.toString() \"R\" } } } 합치면 완성. 123456789101112131415161718192021222324252627282930fun solution(numbers: IntArray, hand: String): String { var answer = \"\" var left = \"*\" var right = \"#\" numbers.forEach { val leftDX = getDistance(left.getLoc(), it.toString().getLoc()).toKeypadDistance() val rightDX = getDistance(right.getLoc(), it.toString().getLoc()).toKeypadDistance() val isInLeftSide = !\"2580369\".contains(it.toString()) val isInMiddleSide = \"2580\".contains(it.toString()) val isLeftCloser = leftDX &lt; rightDX || (leftDX == rightDX &amp;&amp; hand == \"left\") answer += when { isInLeftSide || (isInMiddleSide &amp;&amp; isLeftCloser) -&gt; { left = it.toString() \"L\" } else -&gt; { right = it.toString() \"R\" } } } return answer }} 바로 정답 문자열에 추가까지 하는 코드입니다. 이것으로도 정답이 나오기는 합니다… 만답을 맞추고나니 방법이 생각났습니다. 좌표값으로 거리 가져오기그냥 문자를 좌표 평면으로 바꾼 뒤\\[|(X1 - X2)| + |(Y1 - Y2)|\\]를 거치면 바로 조건에서 말한 거리가 나옵니다…. 123val leftDX = getDistance(left.getLoc(), it.toString().getLoc()).toKeypadDistance()val rightDX = getDistance(right.getLoc(), it.toString().getLoc()).toKeypadDistance() 코드를 수정하고 다시 제출해도 정답이 나왔습니다. 정답 코드123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import kotlin.math.absclass Solution { fun solution(numbers: IntArray, hand: String): String { var answer = \"\" var left = \"*\" var right = \"#\" numbers.forEach { val leftDX = left.getLoc().getKeypadDistance(it.toString().getLoc()) val rightDX = right.getLoc().getKeypadDistance(it.toString().getLoc()) // println(\"$leftDX, $rightDX\") val isInLeftSide = !\"2580369\".contains(it.toString()) val isInMiddleSide = \"2580\".contains(it.toString()) val isLeftCloser = leftDX &lt; rightDX || (leftDX == rightDX &amp;&amp; hand == \"left\") answer += when { isInLeftSide || (isInMiddleSide &amp;&amp; isLeftCloser) -&gt; { left = it.toString() \"L\" } else -&gt; { right = it.toString() \"R\" } } } return answer } fun String.getLoc(): Pair&lt;Int, Int&gt; { /* ^ * 4 | 1 2 3 * 3 | 4 5 6 * 2 | 7 8 9 * 1 | * 0 # * ㅡ|ㅡㅡㅡㅡㅡ&gt; * | 1 2 3 */ val keyNum = \"*0#789456123\".indexOf(this) + 3 return Pair(keyNum % 3 + 1, keyNum / 3) } fun Pair&lt;Int, Int&gt;.getKeypadDistance(p: Pair&lt;Int, Int&gt;): Int = abs(this.first - p.first) + abs(this.second - p.second)} 출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges","link":"/2020/10/25/kakao-intern-press-keypad/"},{"title":"[Level 2] 프로그래머스 프린터 코틀린 풀이","text":"[Level 2] 프로그래머스 프린터 코틀린 풀이 문제 소개이번에 풀어볼 문제는 프린터 입니다 각 문서에 중요도가 붙어있고 리스트에 넣어져있는데, 중요도가 제일 높거나 같으면 출력 아니라면 맨 뒤로 보내는것을 반복하면서 작동합니다. 문제풀이제일 먼저 123var arr = priorities.mapIndexed { index, value -&gt; Pair(value, index == location)} 을 통해서 입력받은 중요도 리스트에서 index == location를 통해서 내가 뽑고 싶은 문서만 true를 달아줍니다. 그 다음 while을 이용해서 리스트가 빌 때 까지 반복을 돌며 1otherArr.any { it.first &gt; tmp.first } 을 통해서 모든 리스트중에서 내가 제일 큰지 확인합니다. 크지 않다면 앞에서 하나를 대기목록의 가장 마지막에 넣고 크다면 정답을 1늘린다 다시 루프를 돌면서 위 과정을 반복하면서 내가 뽑고싶은 문서를 찾습니다. 내가 뽑고 싶은 문제가 나오면 break를 걸고 정답을 출력합니다. 정답 코드123456789101112131415161718192021222324class Solution { fun solution(priorities: IntArray, location: Int): Int { var answer = 1 var arr = priorities.mapIndexed { index, value -&gt; Pair(value, index == location) } loop@ while (arr.isNotEmpty()) { val tmp = arr[0] val otherArr = arr.subList(1, arr.size) arr = when { otherArr.any { it.first &gt; tmp.first } -&gt; otherArr + tmp tmp.second -&gt; break@loop else -&gt; { answer++ otherArr } } } return answer }} 문제의 핵심은 제시한대로 코드를 짜서 직접 프린터 로직을 따라가는 구현이었던것 같습니다 점점 문제가 어려워지는게 느껴집니다.궁금한점이 있으면 댓글로 남겨주세요 :) 출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges","link":"/2021/02/14/printer/"},{"title":"[Level 2, 카카오 블라인드 채용] 프로그래머스 문자열 압축 코틀린 풀이","text":"[Level 2, 카카오 블라인드 채용] 프로그래머스 문자열 압축 코틀린 풀이 문제 소개이번에 풀어볼 문제는 문자열 압축입니다. 몇가지 패턴으로 중복되는 문자열들을 주고 겹치는 문자들은 몇번 겹치는지 숫자로 표기해서 압축을 시킵니다. 문제를 읽고나니 조금 특이한 런 렝스 부호화라는 것을 알 수 있습니다. 런 렝스 부호화는 1개의 단위로 문자열을 자르지만 이 문제에서는 1개 이상의 단위로 문자열을 자르는 것이죠 문제풀이 잘라!먼저 문제에서 시키는대로 문자열을 잘라봅시다 원본 문자열이 &quot;ababcdcdababcdcd&quot; 라면 글자수가 16글자니 자르는 방법도 16개가 있겠군요. 하지만 잘 생각해보면 원본 문자열 글자수의 절반 이상은 생각할 필요가 없습니다. 저 문자열을 8글자를 초과해서 자른다면 &quot;ababcdcda&quot;, &quot;babcdcd&quot; 와 같이 항상 두개로 쪼개지게 되는데 뒤의 문자열이 항상 앞의 문자열보다 짧기 때문에 절대로 겹치는 일이 없으니 생각할 필요가 없습니다. 그럼 이제 1 ~ 문자열길이의 절반을 돌면서 전부 압축해보고 글자수를 비교하면 되는데 가장 처음 해야할건 문자열 자르기입니다. 2단위로 문자열을 자른다면 [[&quot;a&quot;, &quot;b&quot;], [&quot;a&quot;, &quot;b&quot;], [&quot;c&quot;, &quot;d&quot;], [&quot;c&quot;, &quot;d&quot;], [&quot;a&quot;, &quot;b&quot;], [&quot;a&quot;, &quot;b&quot;], [&quot;c&quot;, &quot;d&quot;], [&quot;c&quot;, &quot;d&quot;]] 처럼 잘라야합니다. 직접 반복을 돌면서 이렇게 구하거나 다른 로직으로 답을 구할 수도 있지만 Kotlin에는 chunked라는 엄청난 함수가 존재하기 때문에 이 방법으로 문제를 풀어볼겁니다. Want to split a collection into a list of lists with custom size? Use the &quot;chunked&quot; function: https://t.co/KzxOw6x3s1Need a list of sliding window snapshots with overlap (and custom step size)? Use &quot;windowed&quot;: https://t.co/mQ59SmshHBThey can also apply transformations directly! pic.twitter.com/2KsBAXuUnJ&mdash; Kotlin (@kotlin) November 25, 2020 문자열을 자르는건 이 함수를 사용하면 매우 간단합니다. 12345// (1..s.length/2)하면 문자열 길이 짧은건 (1..0)되어서 오류떠서 +1로 간단하게 처리함(1..s.length/2 + 1).forEach { r -&gt; val chunk = s.chunked(r) // 변수에 담아두자} – 체크! 압축!반복을 체크할 차례입니다. 먼저 두번째부터 돌면서 앞에것과 같은지 체크합니다. 앞에꺼랑 다르다는건 바로 앞의 단어들이 겹친거니 합쳐줍니다. 이 과정을 반복해주면 압축이 됩니다. 저는 map을 이용하여 이 부분을 만들건데 겹치지 않으면 &quot;&quot;, 겹친다면 &quot;2ab&quot;처럼 압축된 문자열을 반환을 시키고 마지막에[&quot;&quot;, &quot;2ab&quot;, &quot;&quot;, &quot;2cd&quot;, &quot;&quot;, &quot;2ab&quot;, &quot;&quot;, &quot;2cd&quot;]처럼 만들어진 배열을 .joinToString(&quot;&quot;)를 이용해서 &quot;2ab2cd2ab2cd&quot;처럼 압축된 문자열을 만들면 됩니다. 이때 count라는 변수를 하나 만들어서 몇번 반복되었는지 담아두었다가 압축시에 사용하면 됩니다. 1val value = \"${if (count == 1) \"\" else count.toString()}${chunk[index]}\" 압축된 문자열을 반환하는 부분에서는 if를 사용하여 1인경우는 생략시켰습니다.문자열 템플릿 밖에서 if를 통해서 처리해도 되지만 전 문자열 템플릿 안에서 if를 사용하여 추가해보았습니다. 12345678910111213141516171819(1..s.length/2 + 1).forEach { r -&gt; val chunk = s.chunked(r) var count = 1 val compressedStr = (chunk.subList(1, chunk.size) + \"\").mapIndexed { index, str -&gt; when (str) { chunk[index] -&gt; { count++ \"\" } else -&gt; { val value = \"${if (count == 1) \"\" else count.toString()}${chunk[index]}\" count = 1 value } } }.joinToString(\"\")} 최소!저희가 필요한건 압축된 문자열이 아니라 몇글자인지만 가져오면 되니까 위의 코드를 살짝 수정해서 정답 함수를 만들면 됩니다. map을 이용해서 list형태로 모아버리면 min()을 이용해서 최소값을 쉽게 구할 수 있습니다.따라서 처음에 12345fun solution(s: String): Int { (1..s.length/2 + 1).forEach { r -&gt; TODO() }} 으로 짰던 코드를 123fun solution(s: String): Int = (1..s.length/2 + 1).map { r -&gt; TODO() }.min()!! 로 바꿨습니다. 12345678910111213141516171819fun solution(s: String): Int = (1..s.length/2 + 1).map { r -&gt; val chunk = s.chunked(r) var count = 1 (chunk.subList(1, chunk.size) + \"\").mapIndexed { index, str -&gt; when (str) { chunk[index] -&gt; { count++ \"\" } else -&gt; { val value = \"${if (count == 1) \"\" else count.toString()}${chunk[index]}\" count = 1 value } } }.joinToString(\"\").length // 글자수만 리턴해주기 }.min()!! // map으로 list형태로 모아서 min()을 이용해서 최소값 구하기 완성! 정답 코드123456789101112131415161718192021class Solution { fun solution(s: String): Int = (1..s.length/2 + 1).map { r -&gt; val chunk = s.chunked(r) var count = 1 (chunk.subList(1, chunk.size) + \"\").mapIndexed { index, str -&gt; when (str) { chunk[index] -&gt; { count++ \"\" } else -&gt; { val value = \"${if (count == 1) \"\" else count.toString()}${chunk[index]}\" count = 1 value } } }.joinToString(\"\").length }.min()!!} 지나가다가 우연히 알게되었던 chunked()함수를 활용해볼 수 있어서 좋았습니다. 출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges","link":"/2020/12/16/2020-kakao-blind-recruitment-string-compression/"}],"tags":[{"name":"code","slug":"code","link":"/tags/code/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"crawling","slug":"crawling","link":"/tags/crawling/"},{"name":"kotlin","slug":"kotlin","link":"/tags/kotlin/"},{"name":"ps","slug":"ps","link":"/tags/ps/"},{"name":"programmers","slug":"programmers","link":"/tags/programmers/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"tensorflow","slug":"tensorflow","link":"/tags/tensorflow/"},{"name":"machine_learning","slug":"machine-learning","link":"/tags/machine-learning/"},{"name":"deep_leanring","slug":"deep-leanring","link":"/tags/deep-leanring/"},{"name":"2020","slug":"2020","link":"/tags/2020/"},{"name":"happy_new_year","slug":"happy-new-year","link":"/tags/happy-new-year/"},{"name":"kotin","slug":"kotin","link":"/tags/kotin/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"gitpage","slug":"gitpage","link":"/tags/gitpage/"},{"name":"seo","slug":"seo","link":"/tags/seo/"},{"name":"gitblog","slug":"gitblog","link":"/tags/gitblog/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"icarus","slug":"icarus","link":"/tags/icarus/"},{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"hexo블로그","slug":"hexo블로그","link":"/tags/hexo%EB%B8%94%EB%A1%9C%EA%B7%B8/"},{"name":"블로그","slug":"블로그","link":"/tags/%EB%B8%94%EB%A1%9C%EA%B7%B8/"},{"name":"boj","slug":"boj","link":"/tags/boj/"},{"name":"math","slug":"math","link":"/tags/math/"},{"name":"numerical_analysis","slug":"numerical-analysis","link":"/tags/numerical-analysis/"},{"name":"solved.ac","slug":"solved-ac","link":"/tags/solved-ac/"},{"name":"profile","slug":"profile","link":"/tags/profile/"},{"name":"readme","slug":"readme","link":"/tags/readme/"},{"name":"tip","slug":"tip","link":"/tags/tip/"},{"name":"recommended","slug":"recommended","link":"/tags/recommended/"},{"name":"SansTyping","slug":"sanstyping","link":"/tags/sanstyping/"},{"name":"와! 샌즈 아시는구나!","slug":"와-샌즈-아시는구나","link":"/tags/%EC%99%80-%EC%83%8C%EC%A6%88-%EC%95%84%EC%8B%9C%EB%8A%94%EA%B5%AC%EB%82%98/"},{"name":"언더테일","slug":"언더테일","link":"/tags/%EC%96%B8%EB%8D%94%ED%85%8C%EC%9D%BC/"},{"name":"샌즈","slug":"샌즈","link":"/tags/%EC%83%8C%EC%A6%88/"},{"name":"Hell-BOJ-Verdict-Message","slug":"hell-boj-verdict-message","link":"/tags/hell-boj-verdict-message/"},{"name":"킹받는익스텐션","slug":"킹받는익스텐션","link":"/tags/%ED%82%B9%EB%B0%9B%EB%8A%94%EC%9D%B5%EC%8A%A4%ED%85%90%EC%85%98/"},{"name":"나정휘.kr","slug":"나정휘-kr","link":"/tags/%EB%82%98%EC%A0%95%ED%9C%98-kr/"},{"name":"pr_practice","slug":"pr-practice","link":"/tags/pr-practice/"},{"name":"repo","slug":"repo","link":"/tags/repo/"},{"name":"2021","slug":"2021","link":"/tags/2021/"}],"categories":[{"name":"Python","slug":"python","link":"/categories/python/"},{"name":"Kotlin","slug":"kotlin","link":"/categories/kotlin/"},{"name":"Problem Solving","slug":"problem-solving","link":"/categories/problem-solving/"},{"name":"Machine Learning","slug":"machine-learning","link":"/categories/machine-learning/"},{"name":"Others","slug":"others","link":"/categories/others/"},{"name":"Programmers","slug":"problem-solving/programmers","link":"/categories/problem-solving/programmers/"},{"name":"Git &amp; GitPage","slug":"git-gitpage","link":"/categories/git-gitpage/"},{"name":"Kotlin","slug":"problem-solving/programmers/kotlin","link":"/categories/problem-solving/programmers/kotlin/"},{"name":"Programming","slug":"programming","link":"/categories/programming/"},{"name":"BOJ","slug":"problem-solving/boj","link":"/categories/problem-solving/boj/"},{"name":"Hexo","slug":"git-gitpage/hexo","link":"/categories/git-gitpage/hexo/"},{"name":"Kotlin","slug":"problem-solving/boj/kotlin","link":"/categories/problem-solving/boj/kotlin/"},{"name":"Github","slug":"git-gitpage/github","link":"/categories/git-gitpage/github/"},{"name":"Recommended","slug":"git-gitpage/recommended","link":"/categories/git-gitpage/recommended/"}]}